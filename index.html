<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Damage Tracker</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f5f5;
      color: #222;
    }

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #f0f4ff, #e3f8ff);
    }

    .app {
      margin: 4rem 1.5rem;
      padding: 2.5rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.1);
      max-width: 520px;
      width: 100%;
    }

    h1 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 2rem;
      letter-spacing: 0.05em;
      color: #274060;
    }

    .total {
      background-color: #274060;
      color: #f7faff;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.75rem;
    }

    .total h2 {
      margin: 0 0 1rem;
      font-size: 1.5rem;
      letter-spacing: 0.04em;
    }

    .total-metrics {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .metric {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 0.85rem 1rem;
    }

    .metric .metric-label {
      display: block;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(247, 250, 255, 0.8);
      margin-bottom: 0.35rem;
    }

    .metric .metric-value {
      font-size: 2rem;
      font-variant-numeric: tabular-nums;
      font-weight: 700;
    }

    .input-row {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
    }

    .input-row input[type="text"] {
      flex: 1;
      padding: 0.85rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    .input-row input[type="text"]:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    button {
      padding: 0.85rem 1.25rem;
      background: #5176ff;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(81, 118, 255, 0.25);
      background: #4063f0;
    }

    button.secondary {
      background: #ecf1ff;
      color: #274060;
    }

    button.secondary:hover {
      background: #d7e2ff;
      box-shadow: 0 8px 16px rgba(39, 64, 96, 0.15);
    }

    .controls {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      flex-wrap: wrap;
      margin-bottom: 1.75rem;
    }

    .monster-manager {
      margin-bottom: 1.75rem;
    }

    .tabs-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: none;
      background: #ecf1ff;
      color: #274060;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      white-space: nowrap;
    }

    .tab[aria-selected='true'] {
      background: #5176ff;
      color: #fff;
      box-shadow: 0 12px 24px rgba(81, 118, 255, 0.25);
    }

    .tab:focus-visible {
      outline: 3px solid rgba(81, 118, 255, 0.4);
      outline-offset: 2px;
    }

    .tab:hover {
      transform: translateY(-1px);
    }

    .monster-form {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: 1fr 1fr auto;
      align-items: center;
    }

    .monster-form input[type='text'] {
      padding: 0.75rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 0.95rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }

    .monster-form input[type='text']:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    .monster-form button {
      white-space: nowrap;
    }

    .monster-form .error {
      grid-column: 1 / -1;
      margin: 0;
    }

    .history {
      background: #f4f7ff;
      border-radius: 12px;
      padding: 1.25rem;
      max-height: 320px;
      overflow-y: auto;
      border: 1px solid #d7e1f5;
    }

    .history h2 {
      margin: 0 0 0.75rem;
      font-size: 1.1rem;
      color: #274060;
    }

    .history ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.6rem;
    }

    .history li {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-left: 5px solid transparent;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.05);
    }

    .history li.damage {
      border-color: #ff6363;
    }

    .history li.heal {
      border-color: #55c28d;
    }

    .history li .label {
      font-size: 0.9rem;
      color: #5b6b82;
    }

    .history li .value {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      color: #274060;
    }

    .empty-message {
      text-align: center;
      color: #7b8ba5;
      font-style: italic;
    }

    .error {
      color: #c62828;
      margin-top: -0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      display: none;
    }

    @media (max-width: 720px) {
      .monster-form {
        grid-template-columns: 1fr;
      }

      .monster-form button {
        width: 100%;
      }
    }

    @media (max-width: 520px) {
      .app {
        margin: 2rem 1rem;
        padding: 1.75rem;
      }

      .input-row {
        flex-direction: column;
      }

      .controls {
        justify-content: stretch;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <main class="app" aria-labelledby="title">
    <h1 id="title">Damage Tracker</h1>
    <section class="monster-manager" aria-label="Monster selection">
      <div class="tabs-container">
        <div id="monster-tabs" class="tabs" role="tablist" aria-label="Monsters"></div>
      </div>
      <div class="monster-form">
        <input
          id="monster-name-input"
          type="text"
          autocomplete="off"
          placeholder="Monster name (optional)"
          aria-label="Monster name (optional)"
        />
        <input
          id="monster-hp-input"
          type="text"
          inputmode="decimal"
          autocomplete="off"
          placeholder="Full HP (optional)"
          aria-label="Full HP (optional)"
        />
        <button id="add-monster-button" type="button">Add Monster</button>
        <p id="monster-form-error" class="error" role="alert"></p>
      </div>
    </section>

    <section class="total" aria-live="polite">
      <h2 id="monster-name-display">Monster #1</h2>
      <div class="total-metrics">
        <div class="metric">
          <span class="metric-label">Total Damage</span>
          <span id="total-damage" class="metric-value">0</span>
        </div>
        <div id="remaining-hp-wrapper" class="metric" hidden>
          <span class="metric-label">Remaining HP</span>
          <span id="remaining-hp" class="metric-value">0</span>
        </div>
      </div>
    </section>

    <div class="input-row">
      <input
        id="damage-input"
        type="text"
        autocomplete="off"
        inputmode="decimal"
        placeholder="Enter damage (e.g. 8 or +5 to heal)"
        aria-label="Damage value"
      />
      <button id="add-button" type="button">Add</button>
    </div>
    <p id="error" class="error" role="alert">Please enter a valid number.</p>

    <div class="controls">
      <button id="undo-button" class="secondary" type="button">Undo</button>
      <button id="reset-button" class="secondary" type="button">Reset</button>
    </div>

    <section class="history" aria-live="polite">
      <h2>History</h2>
      <ul id="history-list"></ul>
      <p id="empty-message" class="empty-message">No damage recorded yet.</p>
    </section>
  </main>

  <script>
    const damageInput = document.getElementById('damage-input');
    const addButton = document.getElementById('add-button');
    const undoButton = document.getElementById('undo-button');
    const resetButton = document.getElementById('reset-button');
    const totalDisplay = document.getElementById('total-damage');
    const remainingHpDisplay = document.getElementById('remaining-hp');
    const remainingHpWrapper = document.getElementById('remaining-hp-wrapper');
    const historyList = document.getElementById('history-list');
    const emptyMessage = document.getElementById('empty-message');
    const errorMessage = document.getElementById('error');
    const monsterTabs = document.getElementById('monster-tabs');
    const monsterNameInput = document.getElementById('monster-name-input');
    const monsterHpInput = document.getElementById('monster-hp-input');
    const addMonsterButton = document.getElementById('add-monster-button');
    const monsterFormError = document.getElementById('monster-form-error');
    const monsterNameDisplay = document.getElementById('monster-name-display');

    const DECIMAL_FACTOR = 10000;
    const numberFormatter = new Intl.NumberFormat(undefined, {
      maximumFractionDigits: 4,
    });

    const monsters = [];
    let activeMonsterId = null;
    let monsterCounter = 0;

    function parseEntry(rawValue) {
      if (!rawValue) {
        return null;
      }

      const isHeal = rawValue.startsWith('+');
      const normalized = isHeal ? rawValue.slice(1) : rawValue;
      const numericValue = parseFloat(normalized);

      if (Number.isNaN(numericValue)) {
        return null;
      }

      return {
        raw: rawValue,
        magnitude: numericValue,
        isHeal,
        effective: isHeal ? -numericValue : numericValue,
      };
    }

    function formatNumber(value) {
      return numberFormatter.format(value);
    }

    function normalizeTotal(value) {
      const normalized = Math.round(value * DECIMAL_FACTOR) / DECIMAL_FACTOR;
      return Math.abs(normalized) < 1e-9 ? 0 : normalized;
    }

    function getActiveMonster() {
      return monsters.find((monster) => monster.id === activeMonsterId) ?? null;
    }

    function createMonster({ name, fullHp }) {
      monsterCounter += 1;
      const trimmedName = (name ?? '').trim();
      const monsterName = trimmedName || `Monster #${monsterCounter}`;
      const sanitizedFullHp = typeof fullHp === 'number' ? normalizeTotal(fullHp) : null;

      return {
        id: `monster-${monsterCounter}`,
        name: monsterName,
        fullHp: sanitizedFullHp,
        history: [],
        totalDamage: 0,
      };
    }

    function ensureActiveMonster() {
      if (monsters.length === 0) {
        activeMonsterId = null;
        return null;
      }

      const current = getActiveMonster();
      if (current) {
        return current;
      }

      activeMonsterId = monsters[0].id;
      return monsters[0];
    }

    function renderTabs() {
      const activeMonster = ensureActiveMonster();

      monsterTabs.innerHTML = '';

      monsters.forEach((monster) => {
        const isActive = activeMonster && monster.id === activeMonster.id;
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'tab';
        tab.setAttribute('role', 'tab');
        tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
        tab.setAttribute('tabindex', isActive ? '0' : '-1');
        tab.textContent = monster.name;
        tab.addEventListener('click', () => {
          if (monster.id !== activeMonsterId) {
            activeMonsterId = monster.id;
            renderTabs();
            refreshActiveMonster();
          }
        });
        monsterTabs.appendChild(tab);
      });
    }

    function updateTotalDisplay(monster) {
      totalDisplay.textContent = formatNumber(monster.totalDamage);
    }

    function updateHpDisplay(monster) {
      if (monster.fullHp == null) {
        remainingHpWrapper.hidden = true;
        return;
      }

      const remaining = normalizeTotal(monster.fullHp - monster.totalDamage);
      const clamped = Math.max(Math.min(remaining, monster.fullHp), 0);
      remainingHpDisplay.textContent = `${formatNumber(clamped)} / ${formatNumber(monster.fullHp)}`;
      remainingHpWrapper.hidden = false;
    }

    function updateMonsterSummary(monster) {
      monsterNameDisplay.textContent = monster.name;
      updateTotalDisplay(monster);
      updateHpDisplay(monster);
    }

    function renderHistory(monster) {
      historyList.innerHTML = '';

      if (!monster || monster.history.length === 0) {
        emptyMessage.textContent = monster ? `No damage recorded for ${monster.name} yet.` : 'Add a monster to begin tracking damage.';
        emptyMessage.style.display = 'block';
        return;
      }

      emptyMessage.style.display = 'none';

      monster.history.forEach((entry, index) => {
        const item = document.createElement('li');
        item.classList.add(entry.isHeal ? 'heal' : 'damage');

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `${entry.isHeal ? 'Heal' : 'Damage'} #${index + 1}`;

        const value = document.createElement('span');
        value.className = 'value';
        value.textContent = entry.raw;

        item.append(label, value);
        historyList.appendChild(item);
      });
    }

    function refreshActiveMonster() {
      const activeMonster = ensureActiveMonster();

      if (!activeMonster) {
        monsterNameDisplay.textContent = 'No monster selected';
        totalDisplay.textContent = formatNumber(0);
        remainingHpWrapper.hidden = true;
        renderHistory(null);
        return;
      }

      updateMonsterSummary(activeMonster);
      renderHistory(activeMonster);
      clearError();
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
    }

    function clearError() {
      errorMessage.style.display = 'none';
    }

    function adjustTotal(monster, delta) {
      monster.totalDamage = normalizeTotal(monster.totalDamage + delta);
    }

    function addEntry() {
      const activeMonster = getActiveMonster();
      if (!activeMonster) {
        showError('Please add a monster before tracking damage.');
        return;
      }

      const rawValue = damageInput.value.trim();
      const entry = parseEntry(rawValue);

      if (!entry) {
        showError('Please enter a valid number.');
        return;
      }

      clearError();
      activeMonster.history.push(entry);
      adjustTotal(activeMonster, entry.effective);
      updateMonsterSummary(activeMonster);
      renderHistory(activeMonster);

      damageInput.value = '';
      damageInput.focus();
    }

    function undoLastEntry() {
      const activeMonster = getActiveMonster();
      if (!activeMonster) {
        return;
      }

      const lastEntry = activeMonster.history.pop();
      if (!lastEntry) {
        return;
      }

      adjustTotal(activeMonster, -lastEntry.effective);
      updateMonsterSummary(activeMonster);
      renderHistory(activeMonster);
    }

    function resetCurrentMonster() {
      const activeMonster = getActiveMonster();
      if (!activeMonster) {
        return;
      }

      activeMonster.history.length = 0;
      activeMonster.totalDamage = 0;
      updateMonsterSummary(activeMonster);
      renderHistory(activeMonster);
      clearError();
      damageInput.value = '';
      damageInput.focus();
    }

    function showMonsterFormError(message) {
      monsterFormError.textContent = message;
      monsterFormError.style.display = 'block';
    }

    function clearMonsterFormError() {
      monsterFormError.textContent = '';
      monsterFormError.style.display = 'none';
    }

    function handleAddMonster() {
      const name = monsterNameInput.value;
      const rawFullHp = monsterHpInput.value.trim();

      let parsedFullHp = null;
      if (rawFullHp) {
        const numericValue = parseFloat(rawFullHp);
        if (Number.isNaN(numericValue) || numericValue <= 0) {
          showMonsterFormError('Please enter a positive number for full HP.');
          monsterHpInput.focus();
          return;
        }
        parsedFullHp = numericValue;
      }

      clearMonsterFormError();

      const monster = createMonster({ name, fullHp: parsedFullHp });
      monsters.push(monster);
      activeMonsterId = monster.id;
      renderTabs();
      refreshActiveMonster();

      monsterNameInput.value = '';
      monsterHpInput.value = '';
      damageInput.focus();
    }

    addButton.addEventListener('click', addEntry);

    damageInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        addEntry();
      }
    });

    undoButton.addEventListener('click', undoLastEntry);
    resetButton.addEventListener('click', resetCurrentMonster);
    addMonsterButton.addEventListener('click', handleAddMonster);

    monsterNameInput.addEventListener('input', clearMonsterFormError);
    monsterHpInput.addEventListener('input', clearMonsterFormError);

    const handleMonsterFormKeydown = (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        handleAddMonster();
      }
    };

    monsterNameInput.addEventListener('keydown', handleMonsterFormKeydown);
    monsterHpInput.addEventListener('keydown', handleMonsterFormKeydown);

    // Initialize with a default monster tab.
    handleAddMonster();
  </script>
</body>
</html>
