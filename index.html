<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DM Toolkit</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f5f5;
      color: #222;
    }

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #f0f4ff, #e3f8ff);
      padding: 2rem 1rem;
      box-sizing: border-box;
    }

    .app {
      padding: 2.5rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.1);
      max-width: 880px;
      width: 100%;
      transition: opacity 0.3s ease;
    }

    h1 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 2rem;
      font-size: 2.1rem;
      letter-spacing: 0.05em;
      color: #274060;
    }

    h2 {
      color: #274060;
      margin-top: 0;
    }

    .section {
      display: grid;
      gap: 1.5rem;
    }

    .form-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: end;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    label {
      font-size: 0.9rem;
      color: #4a5d78;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 0.85rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      background: rgba(255, 255, 255, 0.9);
      color: #1f2933;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    input::placeholder {
      color: rgba(39, 64, 96, 0.6);
    }

    .radio-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .radio-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #cfd8e3;
      background: rgba(255, 255, 255, 0.7);
    }

    .radio-option input {
      accent-color: #5176ff;
    }

    button {
      padding: 0.85rem 1.25rem;
      background: #5176ff;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(81, 118, 255, 0.25);
      background: #4063f0;
    }

    button.secondary {
      background: #ecf1ff;
      color: #274060;
    }

    button.secondary:hover {
      background: #d7e2ff;
      box-shadow: 0 8px 16px rgba(39, 64, 96, 0.15);
    }

    button:disabled,
    button[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .error {
      color: #c62828;
      font-size: 0.9rem;
      display: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(244, 247, 255, 0.9);
      border-radius: 12px;
      overflow: hidden;
    }

    th,
    td {
      padding: 0.85rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(207, 216, 227, 0.6);
      font-size: 0.95rem;
    }

    th {
      background: rgba(81, 118, 255, 0.12);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      color: #4a5d78;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .empty-message {
      text-align: center;
      color: #7b8ba5;
      font-style: italic;
    }

    .turn-tracker {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .turn-order {
      display: flex;
      flex: 1;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.35rem;
    }

    .turn-pill {
      white-space: nowrap;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: #ecf1ff;
      color: #274060;
      font-size: 0.9rem;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .turn-pill:hover {
      transform: translateY(-1px);
    }

    .turn-pill[aria-current="true"] {
      background: #5176ff;
      color: #fff;
      box-shadow: 0 12px 24px rgba(81, 118, 255, 0.25);
    }

    .current-turn {
      font-weight: 600;
      color: #274060;
    }

    .tabs-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: none;
      background: #ecf1ff;
      color: #274060;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      white-space: nowrap;
    }

    .tab[aria-selected="true"] {
      background: #5176ff;
      color: #fff;
      box-shadow: 0 12px 24px rgba(81, 118, 255, 0.25);
    }

    .tab:focus-visible {
      outline: 3px solid rgba(81, 118, 255, 0.4);
      outline-offset: 2px;
    }

    .tab:hover {
      transform: translateY(-1px);
    }

    .combatant-manager {
      margin-bottom: 2rem;
    }

    .combatant-manager table {
      margin-bottom: 0.5rem;
    }

    .combatant-manager input[type="text"],
    .combatant-manager input[type="number"] {
      width: 100%;
      box-sizing: border-box;
    }

    .total {
      background-color: #274060;
      color: #f7faff;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.75rem;
    }

    .total h2 {
      margin: 0 0 1rem;
      font-size: 1.5rem;
      letter-spacing: 0.04em;
    }

    .total-metrics {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .metric {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 0.85rem 1rem;
    }

    .metric .metric-label {
      display: block;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(247, 250, 255, 0.8);
      margin-bottom: 0.35rem;
    }

    .metric .metric-value {
      font-size: 2rem;
      font-variant-numeric: tabular-nums;
      font-weight: 700;
    }

    .input-row {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
    }

    .input-row input[type="text"] {
      flex: 1;
      padding: 0.85rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      color: #1f2933;
    }

    .input-row input[type="text"]:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    .controls {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      flex-wrap: wrap;
      margin-bottom: 1.75rem;
    }

    .history {
      background: #f4f7ff;
      border-radius: 12px;
      padding: 1.25rem;
      max-height: 320px;
      overflow-y: auto;
      border: 1px solid #d7e1f5;
    }

    .history h2 {
      margin: 0 0 0.75rem;
      font-size: 1.1rem;
      color: #274060;
    }

    .history ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.6rem;
    }

    .history li {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-left: 5px solid transparent;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.05);
    }

    .history li.damage {
      border-color: #ff6363;
    }

    .history li.heal {
      border-color: #55c28d;
    }

    .history li .label {
      font-size: 0.9rem;
      color: #5b6b82;
    }

    .history li .value {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      color: #274060;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        background-color: #0f172a;
        color: #e2e8f0;
      }

      body {
        background: linear-gradient(135deg, #1f2937, #0f172a);
      }

      .app {
        background: rgba(15, 23, 42, 0.9);
        box-shadow: 0 25px 45px rgba(0, 0, 0, 0.4);
      }

      h1,
      h2 {
        color: #bfdbfe;
      }

      label {
        color: #cbd5f5;
      }

      input[type="text"],
      input[type="number"],
      select {
        background: rgba(15, 23, 42, 0.85);
        border-color: #475569;
        color: #f8fafc;
      }

      .input-row input[type="text"] {
        background: rgba(15, 23, 42, 0.85);
        border-color: #475569;
        color: #f8fafc;
      }

      input::placeholder {
        color: rgba(226, 232, 240, 0.7);
      }

      .radio-option {
        background: rgba(30, 41, 59, 0.7);
        border-color: #475569;
      }

      .turn-pill {
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
      }

      .turn-pill[aria-current="true"] {
        background: #3b82f6;
        color: #f8fafc;
      }

      .tab {
        background: rgba(30, 41, 59, 0.85);
        color: #e2e8f0;
      }

      .tab[aria-selected="true"] {
        background: #3b82f6;
        color: #f8fafc;
        box-shadow: 0 12px 24px rgba(59, 130, 246, 0.35);
      }

      .total {
        background-color: #1e293b;
        color: #e2e8f0;
      }

      .total .metric {
        background: rgba(255, 255, 255, 0.05);
      }

      .metric .metric-label {
        color: rgba(226, 232, 240, 0.8);
      }

      .history {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid #1f2937;
      }

      .history li {
        background: rgba(30, 41, 59, 0.9);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      }

      .history li .label {
        color: #cbd5f5;
      }

      .history li .value {
        color: #f8fafc;
      }

      table {
        background: rgba(15, 23, 42, 0.85);
      }

      th {
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
      }

      td {
        color: #e2e8f0;
      }

      .empty-message {
        color: #94a3b8;
      }

      button.secondary {
        background: rgba(59, 130, 246, 0.15);
        color: #e2e8f0;
      }

      button.secondary:hover {
        background: rgba(59, 130, 246, 0.25);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.4);
      }
    }

    @media (max-width: 720px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .input-row {
        flex-direction: column;
      }

      .controls {
        justify-content: stretch;
      }

      button {
        width: 100%;
      }

      .turn-tracker {
        flex-direction: column;
        align-items: stretch;
      }

      .turn-order {
        width: 100%;
      }
    }

    @media (max-width: 520px) {
      .app {
        padding: 1.75rem;
      }
    }
  </style>
</head>
<body>
  <main id="initiative-app" class="app" aria-labelledby="initiative-title">
    <h1 id="initiative-title">Initiative Tracker</h1>
    <section class="section" aria-label="Initiative entry">
      <div class="form-grid">
        <div class="field">
          <label for="combatant-name">Combatant Name</label>
          <input id="combatant-name" type="text" placeholder="e.g. Aelar" autocomplete="off" />
        </div>
        <div class="field">
          <label for="combatant-type">Type</label>
          <select id="combatant-type">
            <option value="PC">PC</option>
            <option value="NPC">NPC</option>
          </select>
        </div>
        <div class="field" style="grid-column: 1 / -1;">
          <label>Roll Mode</label>
          <div class="radio-group" role="radiogroup" aria-label="Roll mode">
            <label class="radio-option">
              <input type="radio" name="roll-mode" value="manual" checked />
              Manual roll
            </label>
            <label class="radio-option">
              <input type="radio" name="roll-mode" value="auto" />
              Auto roll
            </label>
          </div>
        </div>
        <div class="field" data-mode="manual">
          <label for="manual-initiative">Initiative Result</label>
          <input id="manual-initiative" type="number" inputmode="decimal" placeholder="e.g. 16" />
        </div>
        <div class="field" data-mode="auto" hidden>
          <label for="auto-modifier">Initiative Modifier</label>
          <input id="auto-modifier" type="number" inputmode="decimal" placeholder="e.g. 3 or -1" value="0" />
        </div>
        <div class="field" data-mode="auto" hidden>
          <label for="auto-advantage">Roll Style</label>
          <select id="auto-advantage">
            <option value="neutral">Neutral</option>
            <option value="adv">Advantage</option>
            <option value="disadv">Disadvantage</option>
          </select>
        </div>
        <div class="field" style="grid-column: 1 / -1;">
          <button id="add-combatant" type="button">Add Combatant</button>
          <p id="initiative-error" class="error" role="alert"></p>
        </div>
      </div>
      <div>
        <h2>Turn Order</h2>
        <table aria-live="polite">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Type</th>
              <th scope="col">Initiative</th>
              <th scope="col">Details</th>
            </tr>
          </thead>
          <tbody id="initiative-tbody"></tbody>
        </table>
        <p id="initiative-empty" class="empty-message">Add combatants to build the initiative order.</p>
      </div>
      <div style="display: flex; justify-content: flex-end;">
        <button id="finish-initiative" type="button" disabled>Finish and Track HP</button>
      </div>
    </section>
  </main>

  <main id="hp-app" class="app" aria-labelledby="hp-title" hidden>
    <h1 id="hp-title">HP Tracker</h1>
    <section class="turn-tracker" aria-label="Turn navigation">
      <button id="prev-combatant" class="secondary" type="button">Previous</button>
      <div class="turn-order" id="turn-order" role="listbox" aria-label="Combatants"></div>
      <button id="next-combatant" class="secondary" type="button">Next</button>
    </section>
    <p id="current-turn" class="current-turn" aria-live="polite"></p>

    <section class="combatant-manager" aria-label="Combatant management">
      <h2>Combatant Order</h2>
      <table aria-live="polite">
        <thead>
          <tr>
            <th scope="col">#</th>
            <th scope="col">Name</th>
            <th scope="col">Type</th>
            <th scope="col">Initiative</th>
          </tr>
        </thead>
        <tbody id="combatant-editor-body"></tbody>
      </table>
      <p id="combatant-editor-empty" class="empty-message">No combatants in this encounter yet.</p>
      <p id="combatant-edit-error" class="error" role="alert"></p>
    </section>

    <section class="monster-manager" aria-label="NPC selection">
      <div class="tabs-container">
        <div id="npc-tabs" class="tabs" role="tablist" aria-label="NPCs"></div>
      </div>
    </section>

    <section class="total" aria-live="polite">
      <h2 id="npc-name-display">No NPC selected</h2>
      <div class="total-metrics">
        <div class="metric">
          <span class="metric-label">Total Damage</span>
          <span id="total-damage" class="metric-value">0</span>
        </div>
        <div id="remaining-hp-wrapper" class="metric" hidden>
          <span class="metric-label">Remaining HP</span>
          <span id="remaining-hp" class="metric-value">0</span>
        </div>
      </div>
    </section>

    <div class="input-row">
      <input
        id="damage-input"
        type="text"
        autocomplete="off"
        inputmode="decimal"
        placeholder="Enter damage (e.g. 8 or +5 to heal)"
        aria-label="Damage value"
      />
      <button id="add-button" type="button">Add</button>
    </div>
    <p id="damage-error" class="error" role="alert">Please enter a valid number.</p>

    <div class="controls">
      <button id="undo-button" class="secondary" type="button">Undo</button>
      <button id="reset-button" class="secondary" type="button">Reset</button>
      <button id="export-button" class="secondary" type="button">Export Encounter</button>
      <button id="import-button" class="secondary" type="button">Import Encounter</button>
    </div>
    <input id="import-input" type="file" accept="application/json" hidden />

    <section class="history" aria-live="polite">
      <h2>History</h2>
      <ul id="history-list"></ul>
      <p id="history-empty" class="empty-message">No damage recorded yet.</p>
    </section>
  </main>

  <script>
    const combatantNameInput = document.getElementById('combatant-name');
    const combatantTypeSelect = document.getElementById('combatant-type');
    const rollModeRadios = Array.from(document.querySelectorAll('input[name="roll-mode"]'));
    const manualInitiativeInput = document.getElementById('manual-initiative');
    const autoModifierInput = document.getElementById('auto-modifier');
    const autoAdvantageSelect = document.getElementById('auto-advantage');
    const manualFields = document.querySelectorAll('[data-mode="manual"]');
    const autoFields = document.querySelectorAll('[data-mode="auto"]');
    const addCombatantButton = document.getElementById('add-combatant');
    const initiativeError = document.getElementById('initiative-error');
    const initiativeTableBody = document.getElementById('initiative-tbody');
    const initiativeEmptyMessage = document.getElementById('initiative-empty');
    const finishInitiativeButton = document.getElementById('finish-initiative');
    const initiativeApp = document.getElementById('initiative-app');
    const hpApp = document.getElementById('hp-app');
    const turnOrderContainer = document.getElementById('turn-order');
    const prevCombatantButton = document.getElementById('prev-combatant');
    const nextCombatantButton = document.getElementById('next-combatant');
    const currentTurnDisplay = document.getElementById('current-turn');
    const combatantEditorBody = document.getElementById('combatant-editor-body');
    const combatantEditorEmpty = document.getElementById('combatant-editor-empty');
    const combatantEditError = document.getElementById('combatant-edit-error');

    const DECIMAL_FACTOR = 10000;
    const numberFormatter = new Intl.NumberFormat(undefined, {
      maximumFractionDigits: 4,
    });

    const combatants = [];
    let combatantCounter = 0;
    let activeCombatantIndex = 0;
    let activeCombatantId = null;

    function setFieldVisibility(mode) {
      const isManual = mode === 'manual';
      manualFields.forEach((field) => {
        field.hidden = !isManual;
        field.setAttribute('aria-hidden', String(!isManual));
      });
      autoFields.forEach((field) => {
        field.hidden = isManual;
        field.setAttribute('aria-hidden', String(isManual));
      });
    }

    rollModeRadios.forEach((radio) => {
      radio.addEventListener('change', (event) => {
        if (event.target.checked) {
          setFieldVisibility(event.target.value);
        }
      });
    });

    setFieldVisibility(rollModeRadios.find((radio) => radio.checked)?.value ?? 'manual');

    function randomD20() {
      return Math.floor(Math.random() * 20) + 1;
    }

    function clearInitiativeError() {
      initiativeError.textContent = '';
      initiativeError.style.display = 'none';
    }

    function showInitiativeError(message) {
      initiativeError.textContent = message;
      initiativeError.style.display = 'block';
    }

    function formatCombatantName(combatant, index) {
      return combatant.name || `${combatant.type} #${index + 1}`;
    }

    function sortCombatants() {
      combatants.sort((a, b) => {
        if (b.initiative !== a.initiative) {
          return b.initiative - a.initiative;
        }
        return a.id - b.id;
      });
    }

    function pushCombatant({ name, type, initiative, details }) {
      const combatant = {
        id: ++combatantCounter,
        name,
        type,
        initiative,
        details: details ?? 'Manual entry',
      };
      combatants.push(combatant);
      return combatant;
    }

    function addCombatant() {
      const name = combatantNameInput.value.trim();
      const type = combatantTypeSelect.value;
      const mode = rollModeRadios.find((radio) => radio.checked)?.value ?? 'manual';

      if (mode === 'manual') {
        const rawInitiative = manualInitiativeInput.value.trim();
        if (rawInitiative === '') {
          showInitiativeError('Enter an initiative value for manual rolls.');
          manualInitiativeInput.focus();
          return;
        }
        const parsed = Number(rawInitiative);
        if (!Number.isFinite(parsed)) {
          showInitiativeError('Please enter a valid number for initiative.');
          manualInitiativeInput.focus();
          return;
        }

        pushCombatant({
          name,
          type,
          initiative: parsed,
          details: 'Manual entry',
        });
      } else {
        const rawModifier = autoModifierInput.value.trim();
        const modifier = rawModifier === '' ? 0 : Number(rawModifier);
        if (!Number.isFinite(modifier)) {
          showInitiativeError('Enter a numeric initiative modifier.');
          autoModifierInput.focus();
          return;
        }

        const rollStyle = autoAdvantageSelect.value;
        const rollOne = randomD20();
        let chosenRoll = rollOne;
        let rollSummary = `Rolled ${rollOne}`;

        if (rollStyle === 'adv' || rollStyle === 'disadv') {
          const rollTwo = randomD20();
          if (rollStyle === 'adv') {
            chosenRoll = Math.max(rollOne, rollTwo);
            rollSummary = `Rolled ${rollOne} & ${rollTwo} (adv) → ${chosenRoll}`;
          } else {
            chosenRoll = Math.min(rollOne, rollTwo);
            rollSummary = `Rolled ${rollOne} & ${rollTwo} (disadv) → ${chosenRoll}`;
          }
        }

        pushCombatant({
          name,
          type,
          initiative: chosenRoll + modifier,
          details:
            modifier === 0
              ? `${rollSummary}`
              : `${rollSummary} + ${modifier >= 0 ? modifier : `(${modifier})`}`,
        });
      }

      clearInitiativeError();
      combatantNameInput.value = '';
      manualInitiativeInput.value = '';
      autoModifierInput.value = '0';
      combatantNameInput.focus();

      renderInitiativeTable();
    }

    function renderInitiativeTable() {
      sortCombatants();

      initiativeTableBody.innerHTML = '';

      if (combatants.length === 0) {
        initiativeEmptyMessage.style.display = 'block';
        finishInitiativeButton.disabled = true;
        return;
      }

      initiativeEmptyMessage.style.display = 'none';
      finishInitiativeButton.disabled = false;

      combatants.forEach((combatant, index) => {
        const row = document.createElement('tr');

        const orderCell = document.createElement('td');
        orderCell.textContent = index + 1;
        row.appendChild(orderCell);

        const nameCell = document.createElement('td');
        nameCell.textContent = formatCombatantName(combatant, index);
        row.appendChild(nameCell);

        const typeCell = document.createElement('td');
        typeCell.textContent = combatant.type;
        row.appendChild(typeCell);

        const initiativeCell = document.createElement('td');
        initiativeCell.textContent = combatant.initiative;
        row.appendChild(initiativeCell);

        const detailsCell = document.createElement('td');
        detailsCell.textContent = combatant.details;
        row.appendChild(detailsCell);

        initiativeTableBody.appendChild(row);
      });
    }

    addCombatantButton.addEventListener('click', addCombatant);

    combatantNameInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    manualInitiativeInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    autoModifierInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    [combatantNameInput, manualInitiativeInput, autoModifierInput].forEach((input) => {
      input.addEventListener('input', clearInitiativeError);
    });

    function setActiveCombatant(index) {
      if (combatants.length === 0) {
        activeCombatantIndex = 0;
        activeCombatantId = null;
        renderTurnOrder();
        return;
      }

      const total = combatants.length;
      const normalizedIndex = (index + total) % total;
      activeCombatantIndex = normalizedIndex;
      activeCombatantId = combatants[normalizedIndex]?.id ?? null;
      renderTurnOrder();
    }

    function renderTurnOrder() {
      sortCombatants();
      const total = combatants.length;
      turnOrderContainer.innerHTML = '';

      if (total === 0) {
        currentTurnDisplay.textContent = '';
        activeCombatantIndex = 0;
        activeCombatantId = null;
        renderCombatantEditor();
        return;
      }

      if (activeCombatantId !== null) {
        const updatedIndex = combatants.findIndex(
          (combatant) => combatant.id === activeCombatantId
        );
        if (updatedIndex !== -1) {
          activeCombatantIndex = updatedIndex;
        } else {
          activeCombatantIndex = 0;
          activeCombatantId = combatants[0].id;
        }
      } else {
        activeCombatantIndex = 0;
        activeCombatantId = combatants[0].id;
      }

      combatants.forEach((combatant, index) => {
        const pill = document.createElement('button');
        pill.type = 'button';
        pill.className = 'turn-pill';
        pill.textContent = `${index + 1}. ${formatCombatantName(combatant, index)} (${combatant.type})`;
        pill.dataset.index = index;
        pill.setAttribute('role', 'option');
        pill.addEventListener('click', () => setActiveCombatant(index));
        if (index === activeCombatantIndex) {
          pill.setAttribute('aria-current', 'true');
        }
        turnOrderContainer.appendChild(pill);
      });

      const activeCombatant = combatants[activeCombatantIndex];
      currentTurnDisplay.textContent = `Current turn: ${formatCombatantName(
        activeCombatant,
        activeCombatantIndex
      )} (${activeCombatant.type}) — Initiative ${activeCombatant.initiative}`;
      renderCombatantEditor();
    }

    function showCombatantEditError(message) {
      if (!combatantEditError) {
        return;
      }

      combatantEditError.textContent = message;
      combatantEditError.style.display = 'block';
    }

    function clearCombatantEditError() {
      if (!combatantEditError) {
        return;
      }

      combatantEditError.textContent = '';
      combatantEditError.style.display = 'none';
    }

    function renderCombatantEditor() {
      if (!combatantEditorBody) {
        return;
      }

      combatantEditorBody.innerHTML = '';

      if (combatantEditorEmpty) {
        combatantEditorEmpty.style.display = combatants.length === 0 ? 'block' : 'none';
      }

      if (combatants.length === 0) {
        clearCombatantEditError();
        return;
      }

      combatants.forEach((combatant, index) => {
        const row = document.createElement('tr');

        const orderCell = document.createElement('td');
        orderCell.textContent = index + 1;
        row.appendChild(orderCell);

        const displayName = formatCombatantName(combatant, index);

        const nameCell = document.createElement('td');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = combatant.name;
        nameInput.placeholder = displayName;
        nameInput.setAttribute('aria-label', `Edit name for ${displayName}`);
        nameInput.addEventListener('focus', clearCombatantEditError);
        nameInput.addEventListener('change', () => {
          combatant.name = nameInput.value.trim();
          clearCombatantEditError();
          renderTurnOrder();
        });
        nameCell.appendChild(nameInput);
        row.appendChild(nameCell);

        const typeCell = document.createElement('td');
        typeCell.textContent = combatant.type;
        row.appendChild(typeCell);

        const initiativeCell = document.createElement('td');
        const initiativeInput = document.createElement('input');
        initiativeInput.type = 'number';
        initiativeInput.inputMode = 'decimal';
        initiativeInput.step = 'any';
        initiativeInput.value = combatant.initiative;
        initiativeInput.setAttribute('aria-label', `Edit initiative for ${displayName}`);
        initiativeInput.addEventListener('focus', clearCombatantEditError);
        initiativeInput.addEventListener('change', () => {
          const rawValue = initiativeInput.value.trim();
          if (rawValue === '') {
            showCombatantEditError('Enter an initiative value.');
            initiativeInput.value = combatant.initiative;
            initiativeInput.focus();
            return;
          }

          const parsed = Number(rawValue);
          if (!Number.isFinite(parsed)) {
            showCombatantEditError('Initiative must be a number.');
            initiativeInput.value = combatant.initiative;
            initiativeInput.focus();
            return;
          }

          combatant.initiative = parsed;
          combatant.details = 'Adjusted manually';
          clearCombatantEditError();
          renderTurnOrder();
        });
        initiativeCell.appendChild(initiativeInput);
        row.appendChild(initiativeCell);

        combatantEditorBody.appendChild(row);
      });
    }

    prevCombatantButton.addEventListener('click', () => {
      setActiveCombatant(activeCombatantIndex - 1);
    });

    nextCombatantButton.addEventListener('click', () => {
      setActiveCombatant(activeCombatantIndex + 1);
    });

    const damageInput = document.getElementById('damage-input');
    const addButton = document.getElementById('add-button');
    const undoButton = document.getElementById('undo-button');
    const resetButton = document.getElementById('reset-button');
    const exportButton = document.getElementById('export-button');
    const importButton = document.getElementById('import-button');
    const importInput = document.getElementById('import-input');
    const totalDisplay = document.getElementById('total-damage');
    const remainingHpDisplay = document.getElementById('remaining-hp');
    const remainingHpWrapper = document.getElementById('remaining-hp-wrapper');
    const historyList = document.getElementById('history-list');
    const historyEmptyMessage = document.getElementById('history-empty');
    const damageError = document.getElementById('damage-error');
    const npcTabs = document.getElementById('npc-tabs');
    const npcNameDisplay = document.getElementById('npc-name-display');

    const npcs = [];
    let activeNpcId = null;
    let npcCounter = 0;

    function parseEntry(rawValue) {
      if (!rawValue) {
        return null;
      }

      const isHeal = rawValue.startsWith('+');
      const normalized = isHeal ? rawValue.slice(1) : rawValue;
      const numericValue = parseFloat(normalized);

      if (Number.isNaN(numericValue)) {
        return null;
      }

      return {
        raw: rawValue,
        magnitude: numericValue,
        isHeal,
        effective: isHeal ? -numericValue : numericValue,
      };
    }

    function formatNumber(value) {
      return numberFormatter.format(value);
    }

    function normalizeTotal(value) {
      const normalized = Math.round(value * DECIMAL_FACTOR) / DECIMAL_FACTOR;
      return Math.abs(normalized) < 1e-9 ? 0 : normalized;
    }

    function buildEncounterState() {
      return {
        version: 1,
        exportedAt: new Date().toISOString(),
        encounterStarted: !hpApp.hidden,
        combatantCounter,
        combatants: combatants.map((combatant) => ({
          id: combatant.id,
          name: combatant.name,
          type: combatant.type,
          initiative: combatant.initiative,
          details: combatant.details,
        })),
        activeCombatantId,
        npcCounter,
        npcs: npcs.map((npc) => ({
          id: npc.id,
          name: npc.name,
          fullHp: npc.fullHp,
          totalDamage: npc.totalDamage,
          history: npc.history.map((entry) => ({
            raw: entry.raw,
            magnitude: entry.magnitude,
            isHeal: entry.isHeal,
            effective: entry.effective,
          })),
        })),
        activeNpcId,
      };
    }

    function applyEncounterState(rawState) {
      if (!rawState || typeof rawState !== 'object') {
        throw new Error('Encounter data is not in a recognized format.');
      }

      const encounterStarted = Boolean(rawState.encounterStarted);

      const sanitizedCombatants = Array.isArray(rawState.combatants)
        ? rawState.combatants
            .map((entry) => {
              const id = Number(entry?.id);
              const initiative = Number(entry?.initiative);
              if (!Number.isFinite(id) || !Number.isFinite(initiative)) {
                return null;
              }

              return {
                id,
                name: typeof entry?.name === 'string' ? entry.name : '',
                type: typeof entry?.type === 'string' ? entry.type : 'Unknown',
                initiative,
                details: typeof entry?.details === 'string' ? entry.details : '',
              };
            })
            .filter(Boolean)
        : [];

      const sanitizedNpcs = Array.isArray(rawState.npcs)
        ? rawState.npcs
            .map((npcEntry) => {
              const id = Number(npcEntry?.id);
              if (!Number.isFinite(id)) {
                return null;
              }

              const history = Array.isArray(npcEntry?.history)
                ? npcEntry.history
                    .map((historyEntry) => {
                      const magnitude = Math.abs(Number(historyEntry?.magnitude));
                      if (!Number.isFinite(magnitude)) {
                        return null;
                      }

                      const isHeal = Boolean(historyEntry?.isHeal);
                      const raw =
                        typeof historyEntry?.raw === 'string'
                          ? historyEntry.raw
                          : String(historyEntry?.raw ?? magnitude);
                      const effective = isHeal ? -magnitude : magnitude;

                      return {
                        raw,
                        magnitude,
                        isHeal,
                        effective,
                      };
                    })
                    .filter(Boolean)
                : [];

              const computedTotal = normalizeTotal(
                history.reduce((sum, entry) => sum + entry.effective, 0)
              );
              const declaredTotal = Number(npcEntry?.totalDamage);
              const totalDamage = Number.isFinite(declaredTotal)
                ? normalizeTotal(declaredTotal)
                : computedTotal;

              const fullHpValue =
                npcEntry?.fullHp === null || npcEntry?.fullHp === undefined
                  ? null
                  : Number(npcEntry.fullHp);

              return {
                id,
                name:
                  typeof npcEntry?.name === 'string' && npcEntry.name.trim()
                    ? npcEntry.name
                    : `NPC #${id}`,
                fullHp: Number.isFinite(fullHpValue) ? fullHpValue : null,
                history,
                totalDamage: Math.abs(totalDamage - computedTotal) < 1e-6
                  ? totalDamage
                  : computedTotal,
              };
            })
            .filter(Boolean)
        : [];

      combatants.length = 0;
      sanitizedCombatants.forEach((combatant) => combatants.push(combatant));

      const maxCombatantId = sanitizedCombatants.reduce(
        (max, combatant) => Math.max(max, combatant.id),
        0
      );
      const declaredCounter = Number(rawState.combatantCounter);
      combatantCounter = Number.isFinite(declaredCounter)
        ? Math.max(declaredCounter, maxCombatantId)
        : maxCombatantId;

      const requestedActiveCombatantId = Number(rawState.activeCombatantId);
      const hasRequestedCombatant = sanitizedCombatants.some(
        (combatant) => combatant.id === requestedActiveCombatantId
      );
      activeCombatantId = hasRequestedCombatant
        ? requestedActiveCombatantId
        : sanitizedCombatants[0]?.id ?? null;
      activeCombatantIndex = sanitizedCombatants.findIndex(
        (combatant) => combatant.id === activeCombatantId
      );
      if (activeCombatantIndex < 0) {
        activeCombatantIndex = 0;
      }

      npcs.length = 0;
      sanitizedNpcs.forEach((npc) => npcs.push(npc));

      const maxNpcId = sanitizedNpcs.reduce((max, npc) => Math.max(max, npc.id), 0);
      const declaredNpcCounter = Number(rawState.npcCounter);
      npcCounter = Number.isFinite(declaredNpcCounter)
        ? Math.max(declaredNpcCounter, maxNpcId)
        : maxNpcId;

      const requestedActiveNpcId = Number(rawState.activeNpcId);
      const hasRequestedNpc = sanitizedNpcs.some((npc) => npc.id === requestedActiveNpcId);
      activeNpcId = hasRequestedNpc ? requestedActiveNpcId : sanitizedNpcs[0]?.id ?? null;

      initiativeApp.hidden = encounterStarted;
      hpApp.hidden = !encounterStarted;

      renderInitiativeTable();
      renderTurnOrder();
      renderNpcTabs();
      refreshActiveNpc();
      clearDamageError();
      clearCombatantEditError();
      damageInput.value = '';
    }

    function getActiveNpc() {
      return npcs.find((npc) => npc.id === activeNpcId) ?? null;
    }

    function createNpc({ name, fullHp }) {
      return {
        id: ++npcCounter,
        name: name || `NPC #${npcCounter}`,
        fullHp: fullHp ?? null,
        history: [],
        totalDamage: 0,
      };
    }

    function renderNpcTabs() {
      npcTabs.innerHTML = '';

      npcs.forEach((npc, index) => {
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'tab';
        tab.textContent = npc.name;
        tab.setAttribute('role', 'tab');
        tab.setAttribute('id', `npc-tab-${npc.id}`);
        tab.addEventListener('click', () => {
          activeNpcId = npc.id;
          refreshActiveNpc();
        });

        if (npc.id === activeNpcId || (activeNpcId === null && index === 0)) {
          activeNpcId = npc.id;
          tab.setAttribute('aria-selected', 'true');
        }

        npcTabs.appendChild(tab);
      });
    }

    function updateNpcSummary(npc) {
      npcNameDisplay.textContent = npc.name;
      totalDisplay.textContent = formatNumber(npc.totalDamage);

      if (typeof npc.fullHp === 'number') {
        const remaining = normalizeTotal(npc.fullHp - npc.totalDamage);
        remainingHpDisplay.textContent = formatNumber(remaining);
        remainingHpWrapper.hidden = false;
      } else {
        remainingHpWrapper.hidden = true;
      }
    }

    function renderHistory(npc) {
      historyList.innerHTML = '';

      if (!npc || npc.history.length === 0) {
        historyEmptyMessage.textContent = npc
          ? `No damage recorded for ${npc.name} yet.`
          : 'Finish initiative with at least one NPC to begin tracking damage.';
        historyEmptyMessage.style.display = 'block';
        return;
      }

      historyEmptyMessage.style.display = 'none';

      npc.history.forEach((entry, index) => {
        const item = document.createElement('li');
        item.classList.add(entry.isHeal ? 'heal' : 'damage');

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `${entry.isHeal ? 'Heal' : 'Damage'} #${index + 1}`;

        const value = document.createElement('span');
        value.className = 'value';
        value.textContent = entry.raw;

        item.append(label, value);
        historyList.appendChild(item);
      });
    }

    function refreshActiveNpc() {
      npcTabs.querySelectorAll('.tab').forEach((tab) => {
        tab.removeAttribute('aria-selected');
      });

      const activeNpc = getActiveNpc();

      if (!activeNpc) {
        npcNameDisplay.textContent = 'No NPC selected';
        totalDisplay.textContent = formatNumber(0);
        remainingHpWrapper.hidden = true;
        renderHistory(null);
        return;
      }

      const activeTab = document.getElementById(`npc-tab-${activeNpc.id}`);
      if (activeTab) {
        activeTab.setAttribute('aria-selected', 'true');
      }

      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
      clearDamageError();
    }

    function showDamageError(message) {
      damageError.textContent = message;
      damageError.style.display = 'block';
    }

    function clearDamageError() {
      damageError.style.display = 'none';
    }

    function adjustTotal(npc, delta) {
      npc.totalDamage = normalizeTotal(npc.totalDamage + delta);
    }

    function addEntry() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        showDamageError('Add an NPC before tracking damage.');
        return;
      }

      const rawValue = damageInput.value.trim();
      const entry = parseEntry(rawValue);

      if (!entry) {
        showDamageError('Please enter a valid number.');
        return;
      }

      clearDamageError();
      activeNpc.history.push(entry);
      adjustTotal(activeNpc, entry.effective);
      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);

      damageInput.value = '';
      damageInput.focus();
    }

    function undoLastEntry() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        return;
      }

      const lastEntry = activeNpc.history.pop();
      if (!lastEntry) {
        return;
      }

      adjustTotal(activeNpc, -lastEntry.effective);
      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
    }

    function resetCurrentNpc() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        return;
      }

      activeNpc.history.length = 0;
      activeNpc.totalDamage = 0;
      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
      clearDamageError();
      damageInput.value = '';
      damageInput.focus();
    }

    function handleAddNpc({ name, fullHp, initiative }) {
      const npc = createNpc({ name, fullHp });
      npcs.push(npc);
      activeNpcId = npc.id;
      renderNpcTabs();
      refreshActiveNpc();

      if (typeof initiative === 'number' && Number.isFinite(initiative)) {
        const newCombatant = pushCombatant({
          name: npc.name,
          type: 'NPC',
          initiative,
          details: 'Manual entry',
        });

        if (activeCombatantId === null) {
          activeCombatantId = newCombatant.id;
        }

        renderTurnOrder();
        clearCombatantEditError();
      }
    }

    addButton.addEventListener('click', addEntry);

    damageInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        addEntry();
      }
    });

    undoButton.addEventListener('click', undoLastEntry);
    resetButton.addEventListener('click', resetCurrentNpc);

    if (exportButton) {
      exportButton.addEventListener('click', () => {
        try {
          const state = buildEncounterState();
          const json = JSON.stringify(state, null, 2);
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement('a');
          anchor.href = url;
          anchor.download = `encounter-${new Date().toISOString().replace(/[.:]/g, '-')}.json`;
          document.body.appendChild(anchor);
          anchor.click();
          anchor.remove();
          setTimeout(() => URL.revokeObjectURL(url), 0);
        } catch (error) {
          console.error('Failed to export encounter', error);
          window.alert('Unable to export the encounter. Please try again.');
        }
      });
    }

    if (importButton && importInput) {
      importButton.addEventListener('click', () => {
        importInput.value = '';
        importInput.click();
      });

      importInput.addEventListener('change', async (event) => {
        const file = event.target.files?.[0];
        if (!file) {
          return;
        }

        try {
          const text = await file.text();
          const parsed = JSON.parse(text);
          applyEncounterState(parsed);
          window.alert('Encounter imported successfully.');
        } catch (error) {
          console.error('Failed to import encounter', error);
          const message =
            error instanceof Error && error.message
              ? error.message
              : 'Unable to import the encounter. Please verify the file and try again.';
          window.alert(message);
        } finally {
          importInput.value = '';
        }
      });
    }

    function finalizeInitiative() {
      if (combatants.length === 0) {
        return;
      }

      initiativeApp.hidden = true;
      hpApp.hidden = false;

      sortCombatants();
      setActiveCombatant(0);

      const npcCombatants = combatants.filter((combatant) => combatant.type === 'NPC');
      npcCombatants.forEach((combatant, index) => {
        handleAddNpc({ name: formatCombatantName(combatant, index), fullHp: null });
      });

      if (npcCombatants.length === 0) {
        npcNameDisplay.textContent = 'No NPCs to track';
      } else {
        activeNpcId = npcs[0]?.id ?? null;
        refreshActiveNpc();
      }
    }

    finishInitiativeButton.addEventListener('click', finalizeInitiative);
  </script>
</body>
</html>
