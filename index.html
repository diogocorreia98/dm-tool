<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DM Toolkit</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f5f5;
      color: #222;
    }

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #f0f4ff, #e3f8ff);
      padding: 2rem 1rem;
      box-sizing: border-box;
    }

    .app {
      padding: 2.5rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.1);
      max-width: 880px;
      width: 100%;
      transition: opacity 0.3s ease;
    }

    h1 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 2rem;
      font-size: 2.1rem;
      letter-spacing: 0.05em;
      color: #274060;
    }

    h2 {
      color: #274060;
      margin-top: 0;
    }

    .section {
      display: grid;
      gap: 1.5rem;
    }

    .form-grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: end;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    label {
      font-size: 0.9rem;
      color: #4a5d78;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 0.85rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      background: rgba(255, 255, 255, 0.9);
      color: #1f2933;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    input::placeholder {
      color: rgba(39, 64, 96, 0.6);
    }

    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .radio-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .radio-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #cfd8e3;
      background: rgba(255, 255, 255, 0.7);
    }

    .radio-option input {
      accent-color: #5176ff;
    }

    button {
      padding: 0.85rem 1.25rem;
      background: #5176ff;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(81, 118, 255, 0.25);
      background: #4063f0;
    }

    button.secondary {
      background: #ecf1ff;
      color: #274060;
    }

    button.secondary:hover {
      background: #d7e2ff;
      box-shadow: 0 8px 16px rgba(39, 64, 96, 0.15);
    }

    button:disabled,
    button[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .error {
      color: #c62828;
      font-size: 0.9rem;
      display: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(244, 247, 255, 0.9);
      border-radius: 12px;
      overflow: hidden;
    }

    th,
    td {
      padding: 0.85rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(207, 216, 227, 0.6);
      font-size: 0.95rem;
    }

    th {
      background: rgba(81, 118, 255, 0.12);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      color: #4a5d78;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .empty-message {
      text-align: center;
      color: #7b8ba5;
      font-style: italic;
    }

    .turn-tracker {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .turn-order {
      display: flex;
      flex: 1;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.35rem;
    }

    .turn-pill {
      white-space: nowrap;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: #ecf1ff;
      color: #274060;
      font-size: 0.9rem;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .turn-pill:hover {
      transform: translateY(-1px);
    }

    .turn-pill[aria-current="true"] {
      background: #5176ff;
      color: #fff;
      box-shadow: 0 12px 24px rgba(81, 118, 255, 0.25);
    }

    .current-turn {
      font-weight: 600;
      color: #274060;
    }

    .tabs-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: none;
      background: #ecf1ff;
      color: #274060;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      white-space: nowrap;
    }

    .tab[aria-selected="true"] {
      background: #5176ff;
      color: #fff;
      box-shadow: 0 12px 24px rgba(81, 118, 255, 0.25);
    }

    .tab:focus-visible {
      outline: 3px solid rgba(81, 118, 255, 0.4);
      outline-offset: 2px;
    }

    .tab:hover {
      transform: translateY(-1px);
    }

    .combatant-manager {
      margin-bottom: 2rem;
    }

    .combatant-manager table {
      margin-bottom: 0.5rem;
    }

    .combatant-manager-actions {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1.5rem;
    }

    .initiative-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1.5rem;
    }

    .combatant-manager input[type="text"],
    .combatant-manager input[type="number"] {
      width: 100%;
      box-sizing: border-box;
    }

    .add-combatant-button {
      margin-top: 1rem;
    }

    .combatant-editor-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .total {
      background-color: #274060;
      color: #f7faff;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.75rem;
    }

    .total h2 {
      margin: 0 0 1rem;
      font-size: 1.5rem;
      letter-spacing: 0.04em;
    }

    .total-metrics {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .metric {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 0.85rem 1rem;
    }

    .metric .metric-label {
      display: block;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(247, 250, 255, 0.8);
      margin-bottom: 0.35rem;
    }

    .metric .metric-value {
      font-size: 2rem;
      font-variant-numeric: tabular-nums;
      font-weight: 700;
    }

    .metric--muted {
      background: rgba(255, 255, 255, 0.06);
    }

    .metric--muted .metric-label {
      color: rgba(247, 250, 255, 0.65);
    }

    .metric--muted .metric-value {
      font-size: 1.6rem;
      font-weight: 600;
      color: rgba(247, 250, 255, 0.85);
    }

    .max-hp-control {
      margin-top: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      max-width: 220px;
    }

    .max-hp-control label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(247, 250, 255, 0.7);
    }

    .max-hp-control input[type="number"] {
      padding: 0.65rem 0.75rem;
      border-radius: 8px;
      border: none;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.18);
      color: #f7faff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
    }

    .max-hp-control input[type="number"]:focus {
      outline: 3px solid rgba(255, 255, 255, 0.4);
      outline-offset: 2px;
    }

    .max-hp-control input[type="number"]::placeholder {
      color: rgba(247, 250, 255, 0.7);
    }

    .input-row {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
    }

    .input-row input[type="text"],
    .input-row input[type="number"] {
      flex: 1;
      padding: 0.85rem 1rem;
      border: 2px solid #cfd8e3;
      border-radius: 10px;
      font-size: 1rem;
      transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      color: #1f2933;
    }

    .input-row input[type="text"]:focus,
    .input-row input[type="number"]:focus {
      border-color: #5176ff;
      box-shadow: 0 0 0 3px rgba(81, 118, 255, 0.2);
      outline: none;
    }

    .controls {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      flex-wrap: wrap;
      margin-bottom: 1.75rem;
    }

    .history {
      background: #f4f7ff;
      border-radius: 12px;
      padding: 1.25rem;
      max-height: 320px;
      overflow-y: auto;
      border: 1px solid #d7e1f5;
    }

    .history h2 {
      margin: 0 0 0.75rem;
      font-size: 1.1rem;
      color: #274060;
    }

    .history ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.6rem;
    }

    .history li {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-left: 5px solid transparent;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.05);
    }

    .history li.damage {
      border-color: #ff6363;
    }

    .history li.heal {
      border-color: #55c28d;
    }

    .history li .label {
      font-size: 0.9rem;
      color: #5b6b82;
    }

    .history li .value {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      color: #274060;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        background-color: #0f172a;
        color: #e2e8f0;
      }

      body {
        background: linear-gradient(135deg, #1f2937, #0f172a);
      }

      .app {
        background: rgba(15, 23, 42, 0.9);
        box-shadow: 0 25px 45px rgba(0, 0, 0, 0.4);
      }

      h1,
      h2 {
        color: #bfdbfe;
      }

      label {
        color: #cbd5f5;
      }

      input[type="text"],
      input[type="number"],
      select {
        background: rgba(15, 23, 42, 0.85);
        border-color: #475569;
        color: #f8fafc;
      }

      .input-row input[type="text"],
      .input-row input[type="number"] {
        background: rgba(15, 23, 42, 0.85);
        border-color: #475569;
        color: #f8fafc;
      }

      input::placeholder {
        color: rgba(226, 232, 240, 0.7);
      }

      .radio-option {
        background: rgba(30, 41, 59, 0.7);
        border-color: #475569;
      }

      .turn-pill {
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
      }

      .turn-pill[aria-current="true"] {
        background: #3b82f6;
        color: #f8fafc;
      }

      .tab {
        background: rgba(30, 41, 59, 0.85);
        color: #e2e8f0;
      }

      .tab[aria-selected="true"] {
        background: #3b82f6;
        color: #f8fafc;
        box-shadow: 0 12px 24px rgba(59, 130, 246, 0.35);
      }

      .total {
        background-color: #1e293b;
        color: #e2e8f0;
      }

      .total .metric {
        background: rgba(255, 255, 255, 0.05);
      }

      .metric .metric-label {
        color: rgba(226, 232, 240, 0.8);
      }

      .history {
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid #1f2937;
      }

      .history li {
        background: rgba(30, 41, 59, 0.9);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      }

      .history li .label {
        color: #cbd5f5;
      }

      .history li .value {
        color: #f8fafc;
      }

      table {
        background: rgba(15, 23, 42, 0.85);
      }

      th {
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
      }

      td {
        color: #e2e8f0;
      }

      .empty-message {
        color: #94a3b8;
      }

      button.secondary {
        background: rgba(59, 130, 246, 0.15);
        color: #e2e8f0;
      }

      button.secondary:hover {
        background: rgba(59, 130, 246, 0.25);
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.4);
      }
    }

    @media (max-width: 720px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .input-row {
        flex-direction: column;
      }

      .controls {
        justify-content: stretch;
      }

      button {
        width: 100%;
      }

      .turn-tracker {
        flex-direction: column;
        align-items: stretch;
      }

      .turn-order {
        width: 100%;
      }
    }

    @media (max-width: 520px) {
      .app {
        padding: 1.75rem;
      }
    }
  </style>
</head>
<body>
  <main id="initiative-app" class="app" aria-labelledby="initiative-title">
    <h1 id="initiative-title">Initiative Tracker</h1>
    <section class="section" aria-label="Initiative entry">
      <div class="form-grid">
        <div class="field">
          <label for="combatant-name">Combatant Name</label>
          <input id="combatant-name" type="text" placeholder="e.g. Aelar" autocomplete="off" />
        </div>
        <div class="field">
          <label for="combatant-type">Type</label>
          <select id="combatant-type">
            <option value="PC">PC</option>
            <option value="NPC">NPC</option>
          </select>
        </div>
        <div class="field" style="grid-column: 1 / -1;">
          <label>Roll Mode</label>
          <div class="radio-group" role="radiogroup" aria-label="Roll mode">
            <label class="radio-option">
              <input type="radio" name="roll-mode" value="manual" checked />
              Manual roll
            </label>
            <label class="radio-option">
              <input type="radio" name="roll-mode" value="auto" />
              Auto roll
            </label>
          </div>
        </div>
        <div class="field" data-mode="manual">
          <label for="manual-initiative">Initiative Result</label>
          <input id="manual-initiative" type="number" inputmode="decimal" placeholder="e.g. 16" />
        </div>
        <div class="field" data-mode="auto" hidden>
          <label for="auto-modifier">Initiative Modifier</label>
          <input id="auto-modifier" type="number" inputmode="decimal" placeholder="e.g. 3 or -1" value="0" />
        </div>
        <div class="field" data-mode="auto" hidden>
          <label for="auto-advantage">Roll Style</label>
          <select id="auto-advantage">
            <option value="neutral">Neutral</option>
            <option value="adv">Advantage</option>
            <option value="disadv">Disadvantage</option>
          </select>
        </div>
        <div class="field" style="grid-column: 1 / -1;">
          <button id="add-combatant" type="button">Add Combatant</button>
          <p id="initiative-error" class="error" role="alert"></p>
        </div>
      </div>
      <div>
        <h2>Turn Order</h2>
        <table aria-live="polite">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Type</th>
              <th scope="col">Initiative</th>
              <th scope="col">Details</th>
            </tr>
          </thead>
          <tbody id="initiative-tbody"></tbody>
        </table>
        <p id="initiative-empty" class="empty-message">Add combatants to build the initiative order.</p>
      </div>
      <div class="initiative-actions">
        <button id="initiative-export-button" class="secondary" type="button">
          Export Encounter
        </button>
        <button id="initiative-import-button" class="secondary" type="button">
          Import Encounter
        </button>
        <button id="finish-initiative" type="button" disabled>Finish and Track HP</button>
      </div>
    </section>
  </main>

  <main id="hp-app" class="app" aria-labelledby="hp-title" hidden>
    <h1 id="hp-title" tabindex="-1">HP Tracker</h1>
    <section class="turn-tracker" aria-label="Turn navigation">
      <button id="prev-combatant" class="secondary" type="button">Previous</button>
      <div class="turn-order" id="turn-order" role="listbox" aria-label="Combatants"></div>
      <button id="next-combatant" class="secondary" type="button">Next</button>
    </section>
    <p id="current-turn" class="current-turn" aria-live="polite"></p>

    <section class="combatant-manager" aria-label="Combatant management">
      <div class="combatant-manager-actions">
        <button id="open-combatant-editor" class="secondary" type="button">
          Edit Combatant List
        </button>
      </div>
    </section>

    <section class="monster-manager" aria-label="NPC selection">
      <div class="tabs-container">
        <div id="npc-tabs" class="tabs" role="tablist" aria-label="NPCs"></div>
      </div>
    </section>

    <section class="total" aria-live="polite">
      <h2 id="npc-name-display">No NPC selected</h2>
      <div class="total-metrics">
        <div class="metric">
          <span class="metric-label">Total Damage</span>
          <span id="total-damage" class="metric-value">0</span>
        </div>
        <div id="remaining-hp-wrapper" class="metric metric--muted" hidden>
          <span class="metric-label">Remaining HP</span>
          <span id="remaining-hp" class="metric-value">0</span>
        </div>
      </div>
      <div class="max-hp-control">
        <label for="max-hp-input">Max HP</label>
        <input
          id="max-hp-input"
          type="number"
          inputmode="decimal"
          step="any"
          placeholder="Set max HP"
          aria-describedby="max-hp-help"
          disabled
        />
        <span id="max-hp-help" class="visually-hidden">Leave blank if no max HP is needed.</span>
      </div>
    </section>

    <div class="input-row">
      <input
        id="damage-input"
        type="text"
        autocomplete="off"
        inputmode="decimal"
        placeholder="Enter damage (e.g. 8 or +5/-5 to heal)"
        aria-label="Damage value"
      />
      <button id="add-button" type="button">Add</button>
    </div>
    <p id="damage-error" class="error" role="alert">Please enter a valid number.</p>

    <div class="input-row">
      <input
        id="temp-hp-input"
        type="number"
        inputmode="decimal"
        step="any"
        placeholder="Set temporary HP"
        aria-label="Temporary HP value"
      />
      <button id="set-temp-hp" type="button">Set Temp HP</button>
    </div>
    <p id="temp-hp-error" class="error" role="alert"></p>

    <div class="controls">
      <button id="undo-button" class="secondary" type="button">Undo</button>
      <button id="reset-button" class="secondary" type="button">Reset</button>
      <button id="export-button" class="secondary" type="button">Export Encounter</button>
      <button id="import-button" class="secondary" type="button">Import Encounter</button>
    </div>
    <input id="import-input" type="file" accept="application/json" hidden />

    <section class="history" aria-live="polite">
      <h2>History</h2>
      <ul id="history-list"></ul>
      <p id="history-empty" class="empty-message">No damage recorded yet.</p>
    </section>
  </main>

  <main
    id="combatant-editor-app"
    class="app"
    aria-labelledby="combatant-editor-title"
    hidden
  >
    <h1 id="combatant-editor-title" tabindex="-1">Combatant List Editor</h1>
    <section class="combatant-manager" aria-label="Combatant list management">
      <h2>Combatant Order</h2>
      <table aria-live="polite">
        <thead>
          <tr>
            <th scope="col">#</th>
            <th scope="col">Name</th>
            <th scope="col">Type</th>
            <th scope="col">Initiative</th>
            <th scope="col">Actions</th>
          </tr>
        </thead>
        <tbody id="combatant-editor-body"></tbody>
      </table>
      <p id="combatant-editor-empty" class="empty-message">No combatants in this encounter yet.</p>
      <p id="combatant-edit-error" class="error" role="alert"></p>
      <button id="hp-add-combatant" class="add-combatant-button" type="button">
        Add New Combatant
      </button>
    </section>
    <div class="combatant-editor-actions">
      <button id="combatant-editor-done" class="secondary" type="button">
        Done Editing
      </button>
    </div>
  </main>

  <script>
    const combatantNameInput = document.getElementById('combatant-name');
    const combatantTypeSelect = document.getElementById('combatant-type');
    const rollModeRadios = Array.from(document.querySelectorAll('input[name="roll-mode"]'));
    const manualInitiativeInput = document.getElementById('manual-initiative');
    const autoModifierInput = document.getElementById('auto-modifier');
    const autoAdvantageSelect = document.getElementById('auto-advantage');
    const manualFields = document.querySelectorAll('[data-mode="manual"]');
    const autoFields = document.querySelectorAll('[data-mode="auto"]');
    const addCombatantButton = document.getElementById('add-combatant');
    const initiativeError = document.getElementById('initiative-error');
    const initiativeTableBody = document.getElementById('initiative-tbody');
    const initiativeEmptyMessage = document.getElementById('initiative-empty');
    const finishInitiativeButton = document.getElementById('finish-initiative');
    const finishInitiativeDefaultLabel =
      finishInitiativeButton?.textContent ?? 'Finish and Track HP';
    const initiativeApp = document.getElementById('initiative-app');
    const hpApp = document.getElementById('hp-app');
    const combatantEditorApp = document.getElementById('combatant-editor-app');
    const turnOrderContainer = document.getElementById('turn-order');
    const prevCombatantButton = document.getElementById('prev-combatant');
    const nextCombatantButton = document.getElementById('next-combatant');
    const currentTurnDisplay = document.getElementById('current-turn');
    const combatantEditorBody = document.getElementById('combatant-editor-body');
    const combatantEditorEmpty = document.getElementById('combatant-editor-empty');
    const combatantEditError = document.getElementById('combatant-edit-error');
    const addCombatantFromHpButton = document.getElementById('hp-add-combatant');
    const openCombatantEditorButton = document.getElementById('open-combatant-editor');
    const closeCombatantEditorButton = document.getElementById('combatant-editor-done');

    const DECIMAL_FACTOR = 10000;
    const numberFormatter = new Intl.NumberFormat(undefined, {
      maximumFractionDigits: 4,
    });

    const combatants = [];
    let combatantCounter = 0;
    let activeCombatantIndex = 0;
    let activeCombatantId = null;
    let isAddingCombatantMidEncounter = false;
    let storedActiveCombatantId = null;
    let storedActiveNpcId = null;
    let midEncounterReturnTarget = 'hp';

    function setFieldHiddenState(field, shouldHide) {
      field.hidden = shouldHide;
      field.setAttribute('aria-hidden', String(shouldHide));
      field
        .querySelectorAll('input, select, textarea, button')
        .forEach((control) => {
          control.disabled = shouldHide;
        });
    }

    function setFieldVisibility(mode) {
      const isManual = mode === 'manual';
      manualFields.forEach((field) => {
        setFieldHiddenState(field, !isManual);
      });
      autoFields.forEach((field) => {
        setFieldHiddenState(field, isManual);
      });
    }

    rollModeRadios.forEach((radio) => {
      radio.addEventListener('change', (event) => {
        if (event.target.checked) {
          setFieldVisibility(event.target.value);
        }
      });
    });

    setFieldVisibility(rollModeRadios.find((radio) => radio.checked)?.value ?? 'manual');

    function randomD20() {
      return Math.floor(Math.random() * 20) + 1;
    }

    function clearInitiativeError() {
      initiativeError.textContent = '';
      initiativeError.style.display = 'none';
    }

    function showInitiativeError(message) {
      initiativeError.textContent = message;
      initiativeError.style.display = 'block';
    }

    function formatCombatantName(combatant, index) {
      const trimmedName = typeof combatant.name === 'string' ? combatant.name.trim() : '';
      if (trimmedName) {
        combatant.generatedName = null;
        return trimmedName;
      }

      const generated = `Combatant #${index + 1}`;
      combatant.generatedName = generated;
      return generated;
    }

    function sortCombatants() {
      combatants.sort((a, b) => {
        if (b.initiative !== a.initiative) {
          return b.initiative - a.initiative;
        }
        return a.id - b.id;
      });
    }

    function pushCombatant({ name, type, initiative, details, npcId }) {
      const combatant = {
        id: ++combatantCounter,
        name: typeof name === 'string' ? name.trim() : '',
        type,
        initiative,
        details: details ?? 'Manual entry',
        npcId: Number.isFinite(npcId) ? npcId : null,
        generatedName: null,
      };
      combatants.push(combatant);
      return combatant;
    }

    function addCombatant() {
      const name = combatantNameInput.value.trim();
      const type = combatantTypeSelect.value;
      const mode = rollModeRadios.find((radio) => radio.checked)?.value ?? 'manual';

      if (mode === 'manual') {
        const rawInitiative = manualInitiativeInput.value.trim();
        let initiativeValue = Number.NaN;
        let details = 'Manual entry';

        if (rawInitiative === '') {
          initiativeValue = randomD20();
          details = 'Manual entry (randomized)';
        } else {
          const parsed = Number(rawInitiative);
          if (!Number.isFinite(parsed)) {
            showInitiativeError('Please enter a valid number for initiative.');
            manualInitiativeInput.focus();
            return;
          }
          initiativeValue = parsed;
        }

        pushCombatant({
          name,
          type,
          initiative: initiativeValue,
          details,
        });
      } else {
        const rawModifier = autoModifierInput.value.trim();
        const modifier = rawModifier === '' ? 0 : Number(rawModifier);
        if (!Number.isFinite(modifier)) {
          showInitiativeError('Enter a numeric initiative modifier.');
          autoModifierInput.focus();
          return;
        }

        const rollStyle = autoAdvantageSelect.value;
        const rollOne = randomD20();
        let chosenRoll = rollOne;
        let rollSummary = `Rolled ${rollOne}`;

        if (rollStyle === 'adv' || rollStyle === 'disadv') {
          const rollTwo = randomD20();
          if (rollStyle === 'adv') {
            chosenRoll = Math.max(rollOne, rollTwo);
            rollSummary = `Rolled ${rollOne} & ${rollTwo} (adv) → ${chosenRoll}`;
          } else {
            chosenRoll = Math.min(rollOne, rollTwo);
            rollSummary = `Rolled ${rollOne} & ${rollTwo} (disadv) → ${chosenRoll}`;
          }
        }

        pushCombatant({
          name,
          type,
          initiative: chosenRoll + modifier,
          details:
            modifier === 0
              ? `${rollSummary}`
              : `${rollSummary} + ${modifier >= 0 ? modifier : `(${modifier})`}`,
        });
      }

      clearInitiativeError();
      combatantNameInput.value = '';
      manualInitiativeInput.value = '';
      autoModifierInput.value = '0';
      combatantNameInput.focus();

      renderInitiativeTable();
    }

    function renderInitiativeTable() {
      sortCombatants();

      initiativeTableBody.innerHTML = '';

      if (combatants.length === 0) {
        initiativeEmptyMessage.style.display = 'block';
        finishInitiativeButton.disabled = true;
        return;
      }

      initiativeEmptyMessage.style.display = 'none';
      finishInitiativeButton.disabled = false;

      combatants.forEach((combatant, index) => {
        const row = document.createElement('tr');

        const orderCell = document.createElement('td');
        orderCell.textContent = index + 1;
        row.appendChild(orderCell);

        const nameCell = document.createElement('td');
        nameCell.textContent = formatCombatantName(combatant, index);
        row.appendChild(nameCell);

        const typeCell = document.createElement('td');
        typeCell.textContent = combatant.type;
        row.appendChild(typeCell);

        const initiativeCell = document.createElement('td');
        initiativeCell.textContent = combatant.initiative;
        row.appendChild(initiativeCell);

        const detailsCell = document.createElement('td');
        detailsCell.textContent = combatant.details;
        row.appendChild(detailsCell);

        initiativeTableBody.appendChild(row);
      });
    }

    addCombatantButton.addEventListener('click', addCombatant);

    combatantNameInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    manualInitiativeInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    autoModifierInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        addCombatant();
      }
    });

    [combatantNameInput, manualInitiativeInput, autoModifierInput].forEach((input) => {
      input.addEventListener('input', clearInitiativeError);
    });

    function setActiveCombatant(index) {
      if (combatants.length === 0) {
        activeCombatantIndex = 0;
        activeCombatantId = null;
        renderTurnOrder();
        return;
      }

      const total = combatants.length;
      const normalizedIndex = (index + total) % total;
      activeCombatantIndex = normalizedIndex;
      activeCombatantId = combatants[normalizedIndex]?.id ?? null;
      renderTurnOrder();
    }

    function setActiveCombatantById(preferredId) {
      if (!Number.isFinite(preferredId)) {
        setActiveCombatant(0);
        return;
      }

      const targetIndex = combatants.findIndex((combatant) => combatant.id === preferredId);
      setActiveCombatant(targetIndex === -1 ? 0 : targetIndex);
    }

    function renderTurnOrder() {
      sortCombatants();
      const total = combatants.length;
      turnOrderContainer.innerHTML = '';

      if (total === 0) {
        currentTurnDisplay.textContent = '';
        activeCombatantIndex = 0;
        activeCombatantId = null;
        renderCombatantEditor();
        return;
      }

      if (activeCombatantId !== null) {
        const updatedIndex = combatants.findIndex(
          (combatant) => combatant.id === activeCombatantId
        );
        if (updatedIndex !== -1) {
          activeCombatantIndex = updatedIndex;
        } else {
          activeCombatantIndex = 0;
          activeCombatantId = combatants[0].id;
        }
      } else {
        activeCombatantIndex = 0;
        activeCombatantId = combatants[0].id;
      }

      combatants.forEach((combatant, index) => {
        const pill = document.createElement('button');
        pill.type = 'button';
        pill.className = 'turn-pill';
        pill.textContent = `${index + 1}. ${formatCombatantName(combatant, index)} (${combatant.type})`;
        pill.dataset.index = index;
        pill.setAttribute('role', 'option');
        pill.addEventListener('click', () => setActiveCombatant(index));
        if (index === activeCombatantIndex) {
          pill.setAttribute('aria-current', 'true');
        }
        turnOrderContainer.appendChild(pill);
      });

      const activeCombatant = combatants[activeCombatantIndex];
      currentTurnDisplay.textContent = `Current turn: ${formatCombatantName(
        activeCombatant,
        activeCombatantIndex
      )} (${activeCombatant.type}) — Initiative ${activeCombatant.initiative}`;
      renderCombatantEditor();
    }

    function showCombatantEditError(message) {
      if (!combatantEditError) {
        return;
      }

      combatantEditError.textContent = message;
      combatantEditError.style.display = 'block';
    }

    function clearCombatantEditError() {
      if (!combatantEditError) {
        return;
      }

      combatantEditError.textContent = '';
      combatantEditError.style.display = 'none';
    }

    function removeCombatant(id) {
      const index = combatants.findIndex((combatant) => combatant.id === id);
      if (index === -1) {
        return;
      }

      const [removed] = combatants.splice(index, 1);

      if (combatants.length === 0) {
        activeCombatantIndex = 0;
        activeCombatantId = null;
      } else if (removed.id === activeCombatantId) {
        const newIndex = Math.min(index, combatants.length - 1);
        activeCombatantIndex = newIndex;
        activeCombatantId = combatants[newIndex].id;
      } else {
        const updatedIndex = combatants.findIndex(
          (combatant) => combatant.id === activeCombatantId
        );
        if (updatedIndex !== -1) {
          activeCombatantIndex = updatedIndex;
        } else {
          activeCombatantIndex = 0;
          activeCombatantId = combatants[0].id;
        }
      }

      const npcIndex = npcs.findIndex(
        (npc) => npc.id === removed.npcId || npc.combatantId === removed.id
      );
      if (npcIndex !== -1) {
        const [removedNpc] = npcs.splice(npcIndex, 1);
        if (activeNpcId === removedNpc.id) {
          activeNpcId = npcs[0]?.id ?? null;
        }
      }

      clearCombatantEditError();
      renderInitiativeTable();
      renderTurnOrder();
      renderNpcTabs();
      refreshActiveNpc();
    }

    function renderCombatantEditor() {
      if (!combatantEditorBody) {
        return;
      }

      combatantEditorBody.innerHTML = '';

      if (combatantEditorEmpty) {
        combatantEditorEmpty.style.display = combatants.length === 0 ? 'block' : 'none';
      }

      if (combatants.length === 0) {
        clearCombatantEditError();
        return;
      }

      combatants.forEach((combatant, index) => {
        const row = document.createElement('tr');

        const orderCell = document.createElement('td');
        orderCell.textContent = index + 1;
        row.appendChild(orderCell);

        const displayName = formatCombatantName(combatant, index);

        const nameCell = document.createElement('td');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = combatant.name;
        nameInput.placeholder = displayName;
        nameInput.setAttribute('aria-label', `Edit name for ${displayName}`);
        nameInput.addEventListener('focus', clearCombatantEditError);
        nameInput.addEventListener('change', () => {
          combatant.name = nameInput.value.trim();
          combatant.generatedName = null;
          clearCombatantEditError();
          renderTurnOrder();
        });
        nameCell.appendChild(nameInput);
        row.appendChild(nameCell);

        const typeCell = document.createElement('td');
        typeCell.textContent = combatant.type;
        row.appendChild(typeCell);

        const initiativeCell = document.createElement('td');
        const initiativeInput = document.createElement('input');
        initiativeInput.type = 'number';
        initiativeInput.inputMode = 'decimal';
        initiativeInput.step = 'any';
        initiativeInput.value = combatant.initiative;
        initiativeInput.setAttribute('aria-label', `Edit initiative for ${displayName}`);
        initiativeInput.addEventListener('focus', clearCombatantEditError);
        initiativeInput.addEventListener('change', () => {
          const rawValue = initiativeInput.value.trim();
          if (rawValue === '') {
            showCombatantEditError('Enter an initiative value.');
            initiativeInput.value = combatant.initiative;
            initiativeInput.focus();
            return;
          }

          const parsed = Number(rawValue);
          if (!Number.isFinite(parsed)) {
            showCombatantEditError('Initiative must be a number.');
            initiativeInput.value = combatant.initiative;
            initiativeInput.focus();
            return;
          }

          combatant.initiative = parsed;
          combatant.details = 'Adjusted manually';
          clearCombatantEditError();
          renderTurnOrder();
        });
        initiativeCell.appendChild(initiativeInput);
        row.appendChild(initiativeCell);

        const actionsCell = document.createElement('td');
        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'secondary';
        removeButton.textContent = 'Remove';
        removeButton.setAttribute(
          'aria-label',
          `Remove ${displayName} from the encounter`
        );
        removeButton.addEventListener('click', () => {
          removeCombatant(combatant.id);
        });
        actionsCell.appendChild(removeButton);
        row.appendChild(actionsCell);

        combatantEditorBody.appendChild(row);
      });
    }

    function openCombatantEditor() {
      if (!combatantEditorApp || !hpApp) {
        return;
      }

      hpApp.hidden = true;
      combatantEditorApp.hidden = false;
      clearCombatantEditError();
      renderCombatantEditor();

      const heading = document.getElementById('combatant-editor-title');
      if (heading) {
        heading.focus();
      }
    }

    function closeCombatantEditor() {
      if (!combatantEditorApp || !hpApp) {
        return;
      }

      combatantEditorApp.hidden = true;
      hpApp.hidden = false;
      midEncounterReturnTarget = 'hp';
      clearCombatantEditError();
      renderTurnOrder();

      const hpHeading = document.getElementById('hp-title');
      if (hpHeading) {
        hpHeading.focus();
      }
    }

    if (openCombatantEditorButton) {
      openCombatantEditorButton.addEventListener('click', openCombatantEditor);
    }

    if (closeCombatantEditorButton) {
      closeCombatantEditorButton.addEventListener('click', closeCombatantEditor);
    }

    function startMidEncounterAddCombatant() {
      if (!initiativeApp || !hpApp) {
        return;
      }

      isAddingCombatantMidEncounter = true;
      storedActiveCombatantId = activeCombatantId;
      storedActiveNpcId = activeNpcId;

      if (combatantEditorApp && !combatantEditorApp.hidden) {
        midEncounterReturnTarget = 'combatant-editor';
      } else {
        midEncounterReturnTarget = 'hp';
      }

      initiativeApp.hidden = false;
      hpApp.hidden = true;
      if (combatantEditorApp) {
        combatantEditorApp.hidden = true;
      }

      const midEncounterLabel =
        midEncounterReturnTarget === 'combatant-editor'
          ? 'Save and Return to Combatant List Editor'
          : 'Save and Return to HP Tracker';
      finishInitiativeButton.textContent = midEncounterLabel;
      clearInitiativeError();

      combatantNameInput.value = '';
      manualInitiativeInput.value = '';
      autoModifierInput.value = '0';

      combatantNameInput.focus();
      renderInitiativeTable();
    }

    if (addCombatantFromHpButton) {
      addCombatantFromHpButton.addEventListener('click', startMidEncounterAddCombatant);
    }

    prevCombatantButton.addEventListener('click', () => {
      setActiveCombatant(activeCombatantIndex - 1);
    });

    nextCombatantButton.addEventListener('click', () => {
      setActiveCombatant(activeCombatantIndex + 1);
    });

    const damageInput = document.getElementById('damage-input');
    const addButton = document.getElementById('add-button');
    const undoButton = document.getElementById('undo-button');
    const resetButton = document.getElementById('reset-button');
    const exportButton = document.getElementById('export-button');
    const initiativeExportButton = document.getElementById('initiative-export-button');
    const importButton = document.getElementById('import-button');
    const initiativeImportButton = document.getElementById('initiative-import-button');
    const importInput = document.getElementById('import-input');
    const totalDisplay = document.getElementById('total-damage');
    const remainingHpDisplay = document.getElementById('remaining-hp');
    const remainingHpWrapper = document.getElementById('remaining-hp-wrapper');
    const maxHpInput = document.getElementById('max-hp-input');
    const historyList = document.getElementById('history-list');
    const historyEmptyMessage = document.getElementById('history-empty');
    const damageError = document.getElementById('damage-error');
    const tempHpInput = document.getElementById('temp-hp-input');
    const setTempHpButton = document.getElementById('set-temp-hp');
    const tempHpError = document.getElementById('temp-hp-error');
    const npcTabs = document.getElementById('npc-tabs');
    const npcNameDisplay = document.getElementById('npc-name-display');

    const npcs = [];
    let activeNpcId = null;
    let npcCounter = 0;

    function parseEntry(rawValue) {
      if (!rawValue) {
        return null;
      }

      const trimmed = rawValue.trim();
      if (trimmed === '') {
        return null;
      }

      const numericValue = Number(trimmed);
      if (!Number.isFinite(numericValue)) {
        return null;
      }

      const isHeal = trimmed.startsWith('+') || trimmed.startsWith('-');
      const magnitude = Math.abs(numericValue);

      return {
        raw: trimmed,
        magnitude,
        isHeal,
        effective: isHeal ? -magnitude : magnitude,
      };
    }

    function formatNumber(value) {
      return numberFormatter.format(value);
    }

    function normalizeTotal(value) {
      const normalized = Math.round(value * DECIMAL_FACTOR) / DECIMAL_FACTOR;
      return Math.abs(normalized) < 1e-9 ? 0 : normalized;
    }

    function buildEncounterState() {
      return {
        version: 2,
        exportedAt: new Date().toISOString(),
        encounterStarted: !hpApp.hidden,
        combatantCounter,
        combatants: combatants.map((combatant) => ({
          id: combatant.id,
          name: combatant.name,
          type: combatant.type,
          initiative: combatant.initiative,
          details: combatant.details,
          npcId: combatant.npcId ?? null,
          generatedName:
            typeof combatant.generatedName === 'string' ? combatant.generatedName : null,
        })),
        activeCombatantId,
        npcCounter,
        npcs: npcs.map((npc) => ({
          id: npc.id,
          name: npc.name,
          fullHp: npc.fullHp,
          totalDamage: npc.totalDamage,
          tempHp: npc.tempHp,
          combatantId: npc.combatantId ?? null,
          history: npc.history.map((entry) => ({
            raw: entry.raw,
            magnitude: entry.magnitude,
            isHeal: entry.isHeal,
            effective: entry.effective,
            hpDelta: entry.hpDelta,
            tempDelta: entry.tempDelta,
          })),
        })),
        activeNpcId,
      };
    }

    function applyEncounterState(rawState) {
      if (!rawState || typeof rawState !== 'object') {
        throw new Error('Encounter data is not in a recognized format.');
      }

      const encounterStarted = Boolean(rawState.encounterStarted);

      const sanitizedCombatants = Array.isArray(rawState.combatants)
        ? rawState.combatants
            .map((entry) => {
              const id = Number(entry?.id);
              const initiative = Number(entry?.initiative);
              if (!Number.isFinite(id) || !Number.isFinite(initiative)) {
                return null;
              }

              const npcIdValue = Number(entry?.npcId);

              return {
                id,
                name: typeof entry?.name === 'string' ? entry.name : '',
                type: typeof entry?.type === 'string' ? entry.type : 'Unknown',
                initiative,
                details: typeof entry?.details === 'string' ? entry.details : '',
                npcId: Number.isFinite(npcIdValue) ? npcIdValue : null,
                generatedName:
                  typeof entry?.generatedName === 'string' ? entry.generatedName : null,
              };
            })
            .filter(Boolean)
        : [];

      const sanitizedNpcs = Array.isArray(rawState.npcs)
        ? rawState.npcs
            .map((npcEntry) => {
              const id = Number(npcEntry?.id);
              if (!Number.isFinite(id)) {
                return null;
              }

              const history = Array.isArray(npcEntry?.history)
                ? npcEntry.history
                    .map((historyEntry) => {
                      const magnitude = Math.abs(Number(historyEntry?.magnitude));
                      if (!Number.isFinite(magnitude)) {
                        return null;
                      }

                      const isHeal = Boolean(historyEntry?.isHeal);
                      const raw =
                        typeof historyEntry?.raw === 'string'
                          ? historyEntry.raw
                          : String(historyEntry?.raw ?? magnitude);
                      const effective = isHeal ? -magnitude : magnitude;
                      const hpDeltaValue = Number(historyEntry?.hpDelta);
                      const tempDeltaValue = Number(historyEntry?.tempDelta);

                      return {
                        raw,
                        magnitude,
                        isHeal,
                        effective,
                        hpDelta: Number.isFinite(hpDeltaValue)
                          ? normalizeTotal(hpDeltaValue)
                          : normalizeTotal(effective),
                        tempDelta: Number.isFinite(tempDeltaValue)
                          ? normalizeTotal(tempDeltaValue)
                          : 0,
                      };
                    })
                    .filter(Boolean)
                : [];

              const computedTotal = history.reduce(
                (sum, entry) => sum + entry.hpDelta,
                0
              );
              const declaredTotal = Number(npcEntry?.totalDamage);
              const normalizedDeclared = Number.isFinite(declaredTotal)
                ? normalizeTotal(declaredTotal)
                : null;
              const normalizedComputed = Math.max(0, normalizeTotal(computedTotal));
              const totalDamage =
                normalizedDeclared !== null &&
                Math.abs(normalizedDeclared - normalizedComputed) < 1e-6
                  ? Math.max(0, normalizedDeclared)
                  : normalizedComputed;

              const fullHpValue =
                npcEntry?.fullHp === null || npcEntry?.fullHp === undefined
                  ? null
                  : Number(npcEntry.fullHp);

              const tempHpValue =
                npcEntry?.tempHp === null || npcEntry?.tempHp === undefined
                  ? 0
                  : Number(npcEntry.tempHp);

              const declaredCombatantId = Number(npcEntry?.combatantId);

              return {
                id,
                name:
                  typeof npcEntry?.name === 'string' && npcEntry.name.trim()
                    ? npcEntry.name
                    : `NPC #${id}`,
                fullHp: Number.isFinite(fullHpValue) ? fullHpValue : null,
                history,
                totalDamage: totalDamage,
                tempHp: Number.isFinite(tempHpValue)
                  ? Math.max(0, normalizeTotal(tempHpValue))
                  : 0,
                combatantId: Number.isFinite(declaredCombatantId)
                  ? declaredCombatantId
                  : null,
              };
            })
            .filter(Boolean)
        : [];

      combatants.length = 0;
      sanitizedCombatants.forEach((combatant) => combatants.push(combatant));

      const maxCombatantId = sanitizedCombatants.reduce(
        (max, combatant) => Math.max(max, combatant.id),
        0
      );
      const declaredCounter = Number(rawState.combatantCounter);
      combatantCounter = Number.isFinite(declaredCounter)
        ? Math.max(declaredCounter, maxCombatantId)
        : maxCombatantId;

      const requestedActiveCombatantId = Number(rawState.activeCombatantId);
      const hasRequestedCombatant = sanitizedCombatants.some(
        (combatant) => combatant.id === requestedActiveCombatantId
      );
      activeCombatantId = hasRequestedCombatant
        ? requestedActiveCombatantId
        : sanitizedCombatants[0]?.id ?? null;
      activeCombatantIndex = sanitizedCombatants.findIndex(
        (combatant) => combatant.id === activeCombatantId
      );
      if (activeCombatantIndex < 0) {
        activeCombatantIndex = 0;
      }

      npcs.length = 0;
      sanitizedNpcs.forEach((npc) => npcs.push(npc));

      const combatantById = new Map(combatants.map((combatant) => [combatant.id, combatant]));
      const npcById = new Map(npcs.map((npc) => [npc.id, npc]));

      combatants.forEach((combatant) => {
        if (combatant.npcId !== null) {
          const linkedNpc = npcById.get(combatant.npcId);
          if (!linkedNpc) {
            combatant.npcId = null;
          } else if (linkedNpc.combatantId === null) {
            linkedNpc.combatantId = combatant.id;
          }
        }
      });

      npcs.forEach((npc) => {
        if (npc.combatantId !== null) {
          const linkedCombatant = combatantById.get(npc.combatantId);
          if (!linkedCombatant) {
            npc.combatantId = null;
          } else {
            linkedCombatant.npcId = npc.id;
          }
        }
      });

      const maxNpcId = sanitizedNpcs.reduce((max, npc) => Math.max(max, npc.id), 0);
      const declaredNpcCounter = Number(rawState.npcCounter);
      npcCounter = Number.isFinite(declaredNpcCounter)
        ? Math.max(declaredNpcCounter, maxNpcId)
        : maxNpcId;

      const requestedActiveNpcId = Number(rawState.activeNpcId);
      const hasRequestedNpc = sanitizedNpcs.some((npc) => npc.id === requestedActiveNpcId);
      activeNpcId = hasRequestedNpc ? requestedActiveNpcId : sanitizedNpcs[0]?.id ?? null;

      initiativeApp.hidden = encounterStarted;
      hpApp.hidden = !encounterStarted;
      if (combatantEditorApp) {
        combatantEditorApp.hidden = true;
      }
      isAddingCombatantMidEncounter = false;
      storedActiveCombatantId = null;
      storedActiveNpcId = null;
      midEncounterReturnTarget = 'hp';
      finishInitiativeButton.textContent = finishInitiativeDefaultLabel;

      renderInitiativeTable();
      renderTurnOrder();
      renderNpcTabs();
      refreshActiveNpc();
      clearDamageError();
      clearCombatantEditError();
      damageInput.value = '';
    }

    function getActiveNpc() {
      return npcs.find((npc) => npc.id === activeNpcId) ?? null;
    }

    function createNpc({ name, fullHp, combatantId }) {
      return {
        id: ++npcCounter,
        name: name || `NPC #${npcCounter}`,
        fullHp: fullHp ?? null,
        history: [],
        totalDamage: 0,
        tempHp: 0,
        combatantId: Number.isFinite(combatantId) ? combatantId : null,
      };
    }

    function renderNpcTabs() {
      npcTabs.innerHTML = '';

      npcs.forEach((npc, index) => {
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'tab';
        tab.textContent = npc.name;
        tab.setAttribute('role', 'tab');
        tab.setAttribute('id', `npc-tab-${npc.id}`);
        tab.addEventListener('click', () => {
          activeNpcId = npc.id;
          refreshActiveNpc();
        });

        if (npc.id === activeNpcId || (activeNpcId === null && index === 0)) {
          activeNpcId = npc.id;
          tab.setAttribute('aria-selected', 'true');
        }

        npcTabs.appendChild(tab);
      });
    }

    function updateNpcSummary(npc) {
      npc.totalDamage = Math.max(0, normalizeTotal(npc.totalDamage));
      npcNameDisplay.textContent = npc.name;
      totalDisplay.textContent = formatNumber(npc.totalDamage);

      const normalizedTemp = Math.max(0, normalizeTotal(Number(npc.tempHp) || 0));
      npc.tempHp = normalizedTemp;
      if (typeof npc.fullHp === 'number') {
        npc.fullHp = Math.max(0, normalizeTotal(npc.fullHp));
      }

      if (maxHpInput) {
        maxHpInput.disabled = false;
        if (typeof npc.fullHp === 'number') {
          maxHpInput.value = String(npc.fullHp);
        } else {
          maxHpInput.value = '';
        }
      }

      if (typeof npc.fullHp === 'number') {
        const maxHp = npc.fullHp;
        if (npc.totalDamage > maxHp) {
          npc.totalDamage = maxHp;
        }
        if (npc.totalDamage < 0) {
          npc.totalDamage = 0;
        }
        const remaining = Math.max(0, normalizeTotal(maxHp - npc.totalDamage));
        const tempDisplay =
          normalizedTemp > 0 ? ` + ${formatNumber(normalizedTemp)} temp` : '';
        remainingHpDisplay.textContent = `${formatNumber(remaining)}${tempDisplay}`;
        remainingHpWrapper.hidden = false;
      } else {
        remainingHpWrapper.hidden = true;
        remainingHpDisplay.textContent = formatNumber(0);
      }
    }

    function renderHistory(npc) {
      historyList.innerHTML = '';

      if (!npc || npc.history.length === 0) {
        historyEmptyMessage.textContent = npc
          ? `No damage recorded for ${npc.name} yet.`
          : 'Finish initiative with at least one NPC to begin tracking damage.';
        historyEmptyMessage.style.display = 'block';
        return;
      }

      historyEmptyMessage.style.display = 'none';

      let damageCount = 0;
      let healCount = 0;

      npc.history.forEach((entry) => {
        const item = document.createElement('li');
        item.classList.add(entry.isHeal ? 'heal' : 'damage');

        const label = document.createElement('span');
        label.className = 'label';
        const labelNumber = entry.isHeal ? ++healCount : ++damageCount;
        label.textContent = `${entry.isHeal ? 'Heal' : 'Damage'} #${labelNumber}`;

        const value = document.createElement('span');
        value.className = 'value';
        value.textContent = entry.raw;

        item.append(label, value);
        historyList.appendChild(item);
      });
    }

    function refreshActiveNpc() {
      npcTabs.querySelectorAll('.tab').forEach((tab) => {
        tab.removeAttribute('aria-selected');
      });

      const activeNpc = getActiveNpc();

      if (!activeNpc) {
        npcNameDisplay.textContent = 'No NPC selected';
        totalDisplay.textContent = formatNumber(0);
        remainingHpWrapper.hidden = true;
        remainingHpDisplay.textContent = formatNumber(0);
        if (maxHpInput) {
          maxHpInput.value = '';
          maxHpInput.disabled = true;
        }
        renderHistory(null);
        return;
      }

      const activeTab = document.getElementById(`npc-tab-${activeNpc.id}`);
      if (activeTab) {
        activeTab.setAttribute('aria-selected', 'true');
      }

      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
      clearDamageError();
      clearTempHpError();
      if (tempHpInput) {
        tempHpInput.value = '';
      }
    }

    function showDamageError(message) {
      damageError.textContent = message;
      damageError.style.display = 'block';
    }

    function clearDamageError() {
      damageError.style.display = 'none';
    }

    function showTempHpError(message) {
      if (!tempHpError) {
        return;
      }
      tempHpError.textContent = message;
      tempHpError.style.display = 'block';
    }

    function clearTempHpError() {
      if (!tempHpError) {
        return;
      }
      tempHpError.textContent = '';
      tempHpError.style.display = 'none';
    }

    function applyEntryEffects(npc, entry) {
      if (!Number.isFinite(npc.totalDamage)) {
        npc.totalDamage = 0;
      }
      if (!Number.isFinite(npc.tempHp)) {
        npc.tempHp = 0;
      }

      let hpDelta = 0;
      let tempDelta = 0;

      if (entry.isHeal) {
        const healAmount = Math.min(entry.magnitude, npc.totalDamage);
        if (healAmount > 0) {
          npc.totalDamage = normalizeTotal(npc.totalDamage - healAmount);
          hpDelta = -healAmount;
        }
        return {
          hpDelta: normalizeTotal(hpDelta),
          tempDelta: normalizeTotal(tempDelta),
        };
      }

      let remaining = entry.magnitude;

      if (npc.tempHp > 0) {
        const consumed = Math.min(remaining, npc.tempHp);
        if (consumed > 0) {
          npc.tempHp = normalizeTotal(npc.tempHp - consumed);
          tempDelta -= consumed;
          remaining = normalizeTotal(remaining - consumed);
        }
      }

      if (remaining > 0) {
        const before = npc.totalDamage;
        let after = before + remaining;
        if (typeof npc.fullHp === 'number') {
          const maxDamage = Math.max(0, normalizeTotal(npc.fullHp));
          after = Math.min(after, maxDamage);
        }
        npc.totalDamage = normalizeTotal(after);
        hpDelta = normalizeTotal(npc.totalDamage - before);
      }

      if (npc.tempHp < 0) {
        npc.tempHp = 0;
      }

      return {
        hpDelta: normalizeTotal(hpDelta),
        tempDelta: normalizeTotal(tempDelta),
      };
    }

    function addEntry() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        showDamageError('Add an NPC before tracking damage.');
        return;
      }

      const rawValue = damageInput.value.trim();
      const entry = parseEntry(rawValue);

      if (!entry) {
        showDamageError('Please enter a valid number.');
        return;
      }

      clearDamageError();
      const { hpDelta, tempDelta } = applyEntryEffects(activeNpc, entry);
      entry.hpDelta = hpDelta;
      entry.tempDelta = tempDelta;
      activeNpc.history.push(entry);
      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);

      damageInput.value = '';
      damageInput.focus();
    }

    function undoLastEntry() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        return;
      }

      const lastEntry = activeNpc.history.pop();
      if (!lastEntry) {
        return;
      }

      const hpDelta = Number.isFinite(lastEntry.hpDelta)
        ? lastEntry.hpDelta
        : lastEntry.effective;
      const tempDelta = Number.isFinite(lastEntry.tempDelta)
        ? lastEntry.tempDelta
        : 0;

      activeNpc.totalDamage = normalizeTotal(activeNpc.totalDamage - hpDelta);
      if (activeNpc.totalDamage < 0) {
        activeNpc.totalDamage = 0;
      }

      if (tempDelta !== 0) {
        activeNpc.tempHp = normalizeTotal(activeNpc.tempHp - tempDelta);
        if (activeNpc.tempHp < 0) {
          activeNpc.tempHp = 0;
        }
      }

      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
    }

    function resetCurrentNpc() {
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        return;
      }

      activeNpc.history.length = 0;
      activeNpc.totalDamage = 0;
      activeNpc.tempHp = 0;
      updateNpcSummary(activeNpc);
      renderHistory(activeNpc);
      clearDamageError();
      clearTempHpError();
      damageInput.value = '';
      if (tempHpInput) {
        tempHpInput.value = '';
      }
      damageInput.focus();
    }

    function setTempHp() {
      if (!tempHpInput) {
        return;
      }
      const activeNpc = getActiveNpc();
      if (!activeNpc) {
        showTempHpError('Add an NPC before assigning temporary HP.');
        return;
      }

      const rawValue = tempHpInput.value.trim();

      if (rawValue === '') {
        activeNpc.tempHp = 0;
        clearTempHpError();
        updateNpcSummary(activeNpc);
        damageInput.focus();
        return;
      }

      const parsed = Number(rawValue);
      if (!Number.isFinite(parsed)) {
        showTempHpError('Please enter a valid number.');
        return;
      }

      if (parsed < 0) {
        showTempHpError('Temporary HP cannot be negative.');
        return;
      }

      const normalized = normalizeTotal(Math.max(0, parsed));
      activeNpc.tempHp = normalized;
      clearTempHpError();
      updateNpcSummary(activeNpc);
      tempHpInput.value = '';
      damageInput.focus();
    }

    function handleAddNpc({ name, fullHp, initiative, combatantId }) {
      const npc = createNpc({ name, fullHp, combatantId });
      npcs.push(npc);
      activeNpcId = npc.id;
      renderNpcTabs();
      refreshActiveNpc();

      if (typeof initiative === 'number' && Number.isFinite(initiative)) {
        const newCombatant = pushCombatant({
          name: npc.name,
          type: 'NPC',
          initiative,
          details: 'Manual entry',
          npcId: npc.id,
        });

        npc.combatantId = newCombatant.id;

        if (activeCombatantId === null) {
          activeCombatantId = newCombatant.id;
        }

        renderTurnOrder();
        clearCombatantEditError();
      } else if (Number.isFinite(combatantId)) {
        const existingCombatant = combatants.find(
          (combatant) => combatant.id === combatantId
        );
        if (existingCombatant) {
          existingCombatant.npcId = npc.id;
          npc.combatantId = existingCombatant.id;
        }
      }

      return npc;
    }

    addButton.addEventListener('click', addEntry);

    damageInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        addEntry();
      }
    });

    if (setTempHpButton) {
      setTempHpButton.addEventListener('click', setTempHp);
    }

    if (tempHpInput) {
      tempHpInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          setTempHp();
        }
      });

      tempHpInput.addEventListener('input', () => {
        if (tempHpError && tempHpError.textContent) {
          clearTempHpError();
        }
      });
    }

    undoButton.addEventListener('click', undoLastEntry);
    resetButton.addEventListener('click', resetCurrentNpc);

    if (maxHpInput) {
      maxHpInput.addEventListener('change', () => {
        const activeNpc = getActiveNpc();
        if (!activeNpc) {
          maxHpInput.value = '';
          return;
        }

        const rawValue = maxHpInput.value.trim();
        if (rawValue === '') {
          activeNpc.fullHp = null;
          updateNpcSummary(activeNpc);
          return;
        }

        const parsed = Number(rawValue);
        if (!Number.isFinite(parsed)) {
          maxHpInput.value =
            typeof activeNpc.fullHp === 'number' ? String(activeNpc.fullHp) : '';
          return;
        }

        activeNpc.fullHp = Math.max(0, normalizeTotal(parsed));
        maxHpInput.value = String(activeNpc.fullHp);
        updateNpcSummary(activeNpc);
      });

      maxHpInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          maxHpInput.blur();
        }
      });

      maxHpInput.addEventListener('blur', () => {
        const activeNpc = getActiveNpc();
        if (!activeNpc) {
          maxHpInput.value = '';
          return;
        }

        maxHpInput.value =
          typeof activeNpc.fullHp === 'number' ? String(activeNpc.fullHp) : '';
      });
    }

    function exportEncounter() {
      try {
        const state = buildEncounterState();
        const json = JSON.stringify(state, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = `encounter-${new Date().toISOString().replace(/[.:]/g, '-')}.json`;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      } catch (error) {
        console.error('Failed to export encounter', error);
        window.alert('Unable to export the encounter. Please try again.');
      }
    }

    const exportButtons = [exportButton, initiativeExportButton].filter(Boolean);
    exportButtons.forEach((button) => {
      button.addEventListener('click', exportEncounter);
    });

    if (importInput) {
      const importButtons = [importButton, initiativeImportButton].filter(Boolean);

      importButtons.forEach((button) => {
        button.addEventListener('click', () => {
          importInput.value = '';
          importInput.click();
        });
      });

      importInput.addEventListener('change', async (event) => {
        const file = event.target.files?.[0];
        if (!file) {
          return;
        }

        try {
          const text = await file.text();
          const parsed = JSON.parse(text);
          applyEncounterState(parsed);
          window.alert('Encounter imported successfully.');
        } catch (error) {
          console.error('Failed to import encounter', error);
          const message =
            error instanceof Error && error.message
              ? error.message
              : 'Unable to import the encounter. Please verify the file and try again.';
          window.alert(message);
        } finally {
          importInput.value = '';
        }
      });
    }

    function finalizeInitiative() {
      if (combatants.length === 0) {
        return;
      }

      sortCombatants();
      renderInitiativeTable();

      const preferredCombatantId =
        isAddingCombatantMidEncounter && Number.isFinite(storedActiveCombatantId)
          ? storedActiveCombatantId
          : null;

      if (preferredCombatantId !== null) {
        setActiveCombatantById(preferredCombatantId);
      } else {
        setActiveCombatant(0);
      }

      const hadNpcBeforeFinalize = npcs.length > 0;
      const previousActiveNpcId =
        isAddingCombatantMidEncounter && Number.isFinite(storedActiveNpcId)
          ? storedActiveNpcId
          : null;

      combatants.forEach((combatant, index) => {
        if (combatant.type === 'NPC' && combatant.npcId === null) {
          const npc = createNpc({
            name: formatCombatantName(combatant, index),
            combatantId: combatant.id,
          });
          npcs.push(npc);
          combatant.npcId = npc.id;
          npc.combatantId = combatant.id;
        }
      });

      let shouldRefreshNpc = false;

      if (npcs.length === 0) {
        npcNameDisplay.textContent = 'No NPCs to track';
        historyList.innerHTML = '';
        historyEmptyMessage.textContent =
          'Finish initiative with at least one NPC to begin tracking damage.';
        historyEmptyMessage.style.display = 'block';
        totalDisplay.textContent = formatNumber(0);
        remainingHpWrapper.hidden = true;
        remainingHpDisplay.textContent = formatNumber(0);

        if (maxHpInput) {
          maxHpInput.value = '';
          maxHpInput.disabled = true;
        }
      } else {
        if (isAddingCombatantMidEncounter) {
          if (
            previousActiveNpcId !== null &&
            npcs.some((npc) => npc.id === previousActiveNpcId)
          ) {
            activeNpcId = previousActiveNpcId;
          } else if (!hadNpcBeforeFinalize) {
            activeNpcId = npcs[0].id;
          } else if (!Number.isFinite(activeNpcId) || !npcs.some((npc) => npc.id === activeNpcId)) {
            activeNpcId = npcs[0].id;
          }
        } else {
          activeNpcId = npcs[0].id;
        }

        shouldRefreshNpc = true;
      }

      renderNpcTabs();
      if (shouldRefreshNpc) {
        refreshActiveNpc();
      }

      initiativeApp.hidden = true;
      clearCombatantEditError();

      if (
        isAddingCombatantMidEncounter &&
        midEncounterReturnTarget === 'combatant-editor' &&
        combatantEditorApp
      ) {
        combatantEditorApp.hidden = false;
        hpApp.hidden = true;
        renderCombatantEditor();

        const heading = document.getElementById('combatant-editor-title');
        if (heading) {
          heading.focus();
        }
      } else {
        hpApp.hidden = false;
        if (combatantEditorApp) {
          combatantEditorApp.hidden = true;
        }

        const hpHeading = document.getElementById('hp-title');
        if (hpHeading) {
          hpHeading.focus();
        }
      }

      finishInitiativeButton.textContent = finishInitiativeDefaultLabel;
      isAddingCombatantMidEncounter = false;
      storedActiveCombatantId = null;
      storedActiveNpcId = null;
      midEncounterReturnTarget = 'hp';
    }

    finishInitiativeButton.addEventListener('click', finalizeInitiative);
  </script>
</body>
</html>
